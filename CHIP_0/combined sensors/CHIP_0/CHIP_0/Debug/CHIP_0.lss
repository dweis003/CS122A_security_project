
CHIP_0.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000004e  00800100  00001238  000012cc  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001238  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          0000064d  0080014e  0080014e  0000131a  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000131a  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000134c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000268  00000000  00000000  0000138c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000290e  00000000  00000000  000015f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000100d  00000000  00000000  00003f02  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000019e2  00000000  00000000  00004f0f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000614  00000000  00000000  000068f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00000f72  00000000  00000000  00006f08  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00001539  00000000  00000000  00007e7a  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000260  00000000  00000000  000093b3  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	45 c0       	rjmp	.+138    	; 0x8c <__ctors_end>
       2:	00 00       	nop
       4:	61 c0       	rjmp	.+194    	; 0xc8 <__bad_interrupt>
       6:	00 00       	nop
       8:	5f c0       	rjmp	.+190    	; 0xc8 <__bad_interrupt>
       a:	00 00       	nop
       c:	5d c0       	rjmp	.+186    	; 0xc8 <__bad_interrupt>
       e:	00 00       	nop
      10:	5b c0       	rjmp	.+182    	; 0xc8 <__bad_interrupt>
      12:	00 00       	nop
      14:	59 c0       	rjmp	.+178    	; 0xc8 <__bad_interrupt>
      16:	00 00       	nop
      18:	57 c0       	rjmp	.+174    	; 0xc8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	55 c0       	rjmp	.+170    	; 0xc8 <__bad_interrupt>
      1e:	00 00       	nop
      20:	53 c0       	rjmp	.+166    	; 0xc8 <__bad_interrupt>
      22:	00 00       	nop
      24:	51 c0       	rjmp	.+162    	; 0xc8 <__bad_interrupt>
      26:	00 00       	nop
      28:	4f c0       	rjmp	.+158    	; 0xc8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	4d c0       	rjmp	.+154    	; 0xc8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	4b c0       	rjmp	.+150    	; 0xc8 <__bad_interrupt>
      32:	00 00       	nop
      34:	82 c5       	rjmp	.+2820   	; 0xb3a <__vector_13>
      36:	00 00       	nop
      38:	47 c0       	rjmp	.+142    	; 0xc8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	45 c0       	rjmp	.+138    	; 0xc8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	43 c0       	rjmp	.+134    	; 0xc8 <__bad_interrupt>
      42:	00 00       	nop
      44:	41 c0       	rjmp	.+130    	; 0xc8 <__bad_interrupt>
      46:	00 00       	nop
      48:	3f c0       	rjmp	.+126    	; 0xc8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	3d c0       	rjmp	.+122    	; 0xc8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	3b c0       	rjmp	.+118    	; 0xc8 <__bad_interrupt>
      52:	00 00       	nop
      54:	39 c0       	rjmp	.+114    	; 0xc8 <__bad_interrupt>
      56:	00 00       	nop
      58:	37 c0       	rjmp	.+110    	; 0xc8 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	35 c0       	rjmp	.+106    	; 0xc8 <__bad_interrupt>
      5e:	00 00       	nop
      60:	33 c0       	rjmp	.+102    	; 0xc8 <__bad_interrupt>
      62:	00 00       	nop
      64:	31 c0       	rjmp	.+98     	; 0xc8 <__bad_interrupt>
      66:	00 00       	nop
      68:	2f c0       	rjmp	.+94     	; 0xc8 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	2d c0       	rjmp	.+90     	; 0xc8 <__bad_interrupt>
      6e:	00 00       	nop
      70:	2b c0       	rjmp	.+86     	; 0xc8 <__bad_interrupt>
      72:	00 00       	nop
      74:	29 c0       	rjmp	.+82     	; 0xc8 <__bad_interrupt>
      76:	00 00       	nop
      78:	27 c0       	rjmp	.+78     	; 0xc8 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	25 c0       	rjmp	.+74     	; 0xc8 <__bad_interrupt>
      7e:	00 00       	nop
      80:	23 c0       	rjmp	.+70     	; 0xc8 <__bad_interrupt>
      82:	00 00       	nop
      84:	21 c0       	rjmp	.+66     	; 0xc8 <__bad_interrupt>
      86:	00 00       	nop
      88:	1f c0       	rjmp	.+62     	; 0xc8 <__bad_interrupt>
	...

0000008c <__ctors_end>:
      8c:	11 24       	eor	r1, r1
      8e:	1f be       	out	0x3f, r1	; 63
      90:	cf ef       	ldi	r28, 0xFF	; 255
      92:	d0 e4       	ldi	r29, 0x40	; 64
      94:	de bf       	out	0x3e, r29	; 62
      96:	cd bf       	out	0x3d, r28	; 61

00000098 <__do_copy_data>:
      98:	11 e0       	ldi	r17, 0x01	; 1
      9a:	a0 e0       	ldi	r26, 0x00	; 0
      9c:	b1 e0       	ldi	r27, 0x01	; 1
      9e:	e8 e3       	ldi	r30, 0x38	; 56
      a0:	f2 e1       	ldi	r31, 0x12	; 18
      a2:	00 e0       	ldi	r16, 0x00	; 0
      a4:	0b bf       	out	0x3b, r16	; 59
      a6:	02 c0       	rjmp	.+4      	; 0xac <__do_copy_data+0x14>
      a8:	07 90       	elpm	r0, Z+
      aa:	0d 92       	st	X+, r0
      ac:	ae 34       	cpi	r26, 0x4E	; 78
      ae:	b1 07       	cpc	r27, r17
      b0:	d9 f7       	brne	.-10     	; 0xa8 <__do_copy_data+0x10>

000000b2 <__do_clear_bss>:
      b2:	27 e0       	ldi	r18, 0x07	; 7
      b4:	ae e4       	ldi	r26, 0x4E	; 78
      b6:	b1 e0       	ldi	r27, 0x01	; 1
      b8:	01 c0       	rjmp	.+2      	; 0xbc <.do_clear_bss_start>

000000ba <.do_clear_bss_loop>:
      ba:	1d 92       	st	X+, r1

000000bc <.do_clear_bss_start>:
      bc:	ab 39       	cpi	r26, 0x9B	; 155
      be:	b2 07       	cpc	r27, r18
      c0:	e1 f7       	brne	.-8      	; 0xba <.do_clear_bss_loop>
      c2:	ce d3       	rcall	.+1948   	; 0x860 <main>
      c4:	0c 94 1a 09 	jmp	0x1234	; 0x1234 <_exit>

000000c8 <__bad_interrupt>:
      c8:	9b cf       	rjmp	.-202    	; 0x0 <__vectors>

000000ca <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
      ca:	cf 93       	push	r28
      cc:	df 93       	push	r29
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
      ce:	ec 01       	movw	r28, r24
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
      d0:	87 d6       	rcall	.+3342   	; 0xde0 <vTaskSuspendAll>
      d2:	20 91 4e 01 	lds	r18, 0x014E	; 0x80014e <__data_end>
      d6:	30 91 4f 01 	lds	r19, 0x014F	; 0x80014f <__data_end+0x1>
      da:	c9 01       	movw	r24, r18
      dc:	8c 0f       	add	r24, r28
      de:	9d 1f       	adc	r25, r29
      e0:	8c 3d       	cpi	r24, 0xDC	; 220
      e2:	45 e0       	ldi	r20, 0x05	; 5
      e4:	94 07       	cpc	r25, r20
      e6:	58 f4       	brcc	.+22     	; 0xfe <pvPortMalloc+0x34>
      e8:	28 17       	cp	r18, r24
      ea:	39 07       	cpc	r19, r25
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
      ec:	58 f4       	brcc	.+22     	; 0x104 <pvPortMalloc+0x3a>
      ee:	e9 01       	movw	r28, r18
      f0:	c0 5b       	subi	r28, 0xB0	; 176
			xNextFreeByte += xWantedSize;			
      f2:	de 4f       	sbci	r29, 0xFE	; 254
      f4:	90 93 4f 01 	sts	0x014F, r25	; 0x80014f <__data_end+0x1>
      f8:	80 93 4e 01 	sts	0x014E, r24	; 0x80014e <__data_end>
static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
void *pvReturn = NULL; 
      fc:	05 c0       	rjmp	.+10     	; 0x108 <pvPortMalloc+0x3e>
      fe:	c0 e0       	ldi	r28, 0x00	; 0
     100:	d0 e0       	ldi	r29, 0x00	; 0
     102:	02 c0       	rjmp	.+4      	; 0x108 <pvPortMalloc+0x3e>
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
			xNextFreeByte += xWantedSize;			
		}	
	}
	xTaskResumeAll();
     104:	c0 e0       	ldi	r28, 0x00	; 0
     106:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	#endif	

	return pvReturn;
}
     108:	32 d7       	rcall	.+3684   	; 0xf6e <xTaskResumeAll>
     10a:	ce 01       	movw	r24, r28
     10c:	df 91       	pop	r29
     10e:	cf 91       	pop	r28
     110:	08 95       	ret

00000112 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     112:	08 95       	ret

00000114 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
     114:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
     116:	03 96       	adiw	r24, 0x03	; 3
     118:	92 83       	std	Z+2, r25	; 0x02
     11a:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
     11c:	2f ef       	ldi	r18, 0xFF	; 255
     11e:	3f ef       	ldi	r19, 0xFF	; 255
     120:	34 83       	std	Z+4, r19	; 0x04
     122:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
     124:	96 83       	std	Z+6, r25	; 0x06
     126:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
     128:	90 87       	std	Z+8, r25	; 0x08
     12a:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
     12c:	10 82       	st	Z, r1
     12e:	08 95       	ret

00000130 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
     130:	fc 01       	movw	r30, r24
     132:	11 86       	std	Z+9, r1	; 0x09
     134:	10 86       	std	Z+8, r1	; 0x08
     136:	08 95       	ret

00000138 <vListInsertEnd>:
}
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
     138:	cf 93       	push	r28
     13a:	df 93       	push	r29
     13c:	fc 01       	movw	r30, r24
     13e:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
     140:	21 81       	ldd	r18, Z+1	; 0x01
     142:	32 81       	ldd	r19, Z+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
     144:	e9 01       	movw	r28, r18
     146:	8a 81       	ldd	r24, Y+2	; 0x02
     148:	9b 81       	ldd	r25, Y+3	; 0x03
     14a:	13 96       	adiw	r26, 0x03	; 3
     14c:	9c 93       	st	X, r25
     14e:	8e 93       	st	-X, r24
     150:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
     152:	81 81       	ldd	r24, Z+1	; 0x01
     154:	92 81       	ldd	r25, Z+2	; 0x02
     156:	15 96       	adiw	r26, 0x05	; 5
     158:	9c 93       	st	X, r25
     15a:	8e 93       	st	-X, r24
     15c:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     15e:	8a 81       	ldd	r24, Y+2	; 0x02
     160:	9b 81       	ldd	r25, Y+3	; 0x03
     162:	ec 01       	movw	r28, r24
     164:	7d 83       	std	Y+5, r23	; 0x05
     166:	6c 83       	std	Y+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
     168:	e9 01       	movw	r28, r18
     16a:	7b 83       	std	Y+3, r23	; 0x03
     16c:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
     16e:	72 83       	std	Z+2, r23	; 0x02
     170:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     172:	19 96       	adiw	r26, 0x09	; 9
     174:	fc 93       	st	X, r31
     176:	ee 93       	st	-X, r30
     178:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
     17a:	80 81       	ld	r24, Z
     17c:	8f 5f       	subi	r24, 0xFF	; 255
     17e:	80 83       	st	Z, r24
}
     180:	df 91       	pop	r29
     182:	cf 91       	pop	r28
     184:	08 95       	ret

00000186 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
     186:	cf 93       	push	r28
     188:	df 93       	push	r29
     18a:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
     18c:	48 81       	ld	r20, Y
     18e:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
     190:	4f 3f       	cpi	r20, 0xFF	; 255
     192:	2f ef       	ldi	r18, 0xFF	; 255
     194:	52 07       	cpc	r21, r18
     196:	31 f4       	brne	.+12     	; 0x1a4 <vListInsert+0x1e>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
     198:	dc 01       	movw	r26, r24
     19a:	17 96       	adiw	r26, 0x07	; 7
     19c:	ed 91       	ld	r30, X+
     19e:	fc 91       	ld	r31, X
     1a0:	18 97       	sbiw	r26, 0x08	; 8
     1a2:	17 c0       	rjmp	.+46     	; 0x1d2 <vListInsert+0x4c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
     1a4:	fc 01       	movw	r30, r24
     1a6:	33 96       	adiw	r30, 0x03	; 3
     1a8:	dc 01       	movw	r26, r24
     1aa:	15 96       	adiw	r26, 0x05	; 5
     1ac:	2d 91       	ld	r18, X+
     1ae:	3c 91       	ld	r19, X
     1b0:	16 97       	sbiw	r26, 0x06	; 6
     1b2:	d9 01       	movw	r26, r18
     1b4:	2d 91       	ld	r18, X+
     1b6:	3c 91       	ld	r19, X
     1b8:	42 17       	cp	r20, r18
     1ba:	53 07       	cpc	r21, r19
     1bc:	50 f0       	brcs	.+20     	; 0x1d2 <vListInsert+0x4c>
     1be:	02 80       	ldd	r0, Z+2	; 0x02
     1c0:	f3 81       	ldd	r31, Z+3	; 0x03
     1c2:	e0 2d       	mov	r30, r0
     1c4:	a2 81       	ldd	r26, Z+2	; 0x02
     1c6:	b3 81       	ldd	r27, Z+3	; 0x03
     1c8:	2d 91       	ld	r18, X+
     1ca:	3c 91       	ld	r19, X
     1cc:	42 17       	cp	r20, r18
     1ce:	53 07       	cpc	r21, r19
     1d0:	b0 f7       	brcc	.-20     	; 0x1be <vListInsert+0x38>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
     1d2:	a2 81       	ldd	r26, Z+2	; 0x02
     1d4:	b3 81       	ldd	r27, Z+3	; 0x03
     1d6:	bb 83       	std	Y+3, r27	; 0x03
     1d8:	aa 83       	std	Y+2, r26	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
     1da:	15 96       	adiw	r26, 0x05	; 5
     1dc:	dc 93       	st	X, r29
     1de:	ce 93       	st	-X, r28
     1e0:	14 97       	sbiw	r26, 0x04	; 4
	pxNewListItem->pxPrevious = pxIterator;
     1e2:	fd 83       	std	Y+5, r31	; 0x05
     1e4:	ec 83       	std	Y+4, r30	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
     1e6:	d3 83       	std	Z+3, r29	; 0x03
     1e8:	c2 83       	std	Z+2, r28	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
     1ea:	99 87       	std	Y+9, r25	; 0x09
     1ec:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
     1ee:	fc 01       	movw	r30, r24
     1f0:	20 81       	ld	r18, Z
     1f2:	2f 5f       	subi	r18, 0xFF	; 255
     1f4:	20 83       	st	Z, r18
}
     1f6:	df 91       	pop	r29
     1f8:	cf 91       	pop	r28
     1fa:	08 95       	ret

000001fc <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
     1fc:	fc 01       	movw	r30, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
     1fe:	a2 81       	ldd	r26, Z+2	; 0x02
     200:	b3 81       	ldd	r27, Z+3	; 0x03
     202:	84 81       	ldd	r24, Z+4	; 0x04
     204:	95 81       	ldd	r25, Z+5	; 0x05
     206:	15 96       	adiw	r26, 0x05	; 5
     208:	9c 93       	st	X, r25
     20a:	8e 93       	st	-X, r24
     20c:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
     20e:	a4 81       	ldd	r26, Z+4	; 0x04
     210:	b5 81       	ldd	r27, Z+5	; 0x05
     212:	82 81       	ldd	r24, Z+2	; 0x02
     214:	93 81       	ldd	r25, Z+3	; 0x03
     216:	13 96       	adiw	r26, 0x03	; 3
     218:	9c 93       	st	X, r25
     21a:	8e 93       	st	-X, r24
     21c:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
     21e:	a0 85       	ldd	r26, Z+8	; 0x08
     220:	b1 85       	ldd	r27, Z+9	; 0x09

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
     222:	11 96       	adiw	r26, 0x01	; 1
     224:	8d 91       	ld	r24, X+
     226:	9c 91       	ld	r25, X
     228:	12 97       	sbiw	r26, 0x02	; 2
     22a:	e8 17       	cp	r30, r24
     22c:	f9 07       	cpc	r31, r25
     22e:	31 f4       	brne	.+12     	; 0x23c <vListRemove+0x40>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
     230:	84 81       	ldd	r24, Z+4	; 0x04
     232:	95 81       	ldd	r25, Z+5	; 0x05
     234:	12 96       	adiw	r26, 0x02	; 2
     236:	9c 93       	st	X, r25
     238:	8e 93       	st	-X, r24
     23a:	11 97       	sbiw	r26, 0x01	; 1
	}

	pxItemToRemove->pvContainer = NULL;
     23c:	11 86       	std	Z+9, r1	; 0x09
     23e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
     240:	8c 91       	ld	r24, X
     242:	81 50       	subi	r24, 0x01	; 1
     244:	8c 93       	st	X, r24
     246:	08 95       	ret

00000248 <ADC_init>:
//MOTOR 2 FSM
enum MotorState_2 {m_wait_2, m_init_2, m_reset_2} motor_state_2;


void Motor_2_Init(){
	motor_state_2 = m_init_2;
     248:	ea e7       	ldi	r30, 0x7A	; 122
     24a:	f0 e0       	ldi	r31, 0x00	; 0
     24c:	80 81       	ld	r24, Z
     24e:	80 6e       	ori	r24, 0xE0	; 224
     250:	80 83       	st	Z, r24
     252:	08 95       	ret

00000254 <TEMP_Tick>:
     254:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <temp_state>
     258:	81 30       	cpi	r24, 0x01	; 1
     25a:	d1 f4       	brne	.+52     	; 0x290 <TEMP_Tick+0x3c>
     25c:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     260:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     264:	22 0f       	add	r18, r18
     266:	33 1f       	adc	r19, r19
     268:	22 0f       	add	r18, r18
     26a:	33 1f       	adc	r19, r19
     26c:	30 93 3b 07 	sts	0x073B, r19	; 0x80073b <temp_MV+0x1>
     270:	20 93 3a 07 	sts	0x073A, r18	; 0x80073a <temp_MV>
     274:	24 5f       	subi	r18, 0xF4	; 244
     276:	31 40       	sbci	r19, 0x01	; 1
     278:	ad ec       	ldi	r26, 0xCD	; 205
     27a:	bc ec       	ldi	r27, 0xCC	; 204
     27c:	b6 d7       	rcall	.+3948   	; 0x11ea <__umulhisi3>
     27e:	96 95       	lsr	r25
     280:	87 95       	ror	r24
     282:	96 95       	lsr	r25
     284:	87 95       	ror	r24
     286:	96 95       	lsr	r25
     288:	87 95       	ror	r24
     28a:	80 93 3c 07 	sts	0x073C, r24	; 0x80073c <temp_val>
     28e:	8b b9       	out	0x0b, r24	; 11
     290:	80 91 99 07 	lds	r24, 0x0799	; 0x800799 <temp_state>
     294:	88 23       	and	r24, r24
     296:	19 f0       	breq	.+6      	; 0x29e <TEMP_Tick+0x4a>
     298:	81 30       	cpi	r24, 0x01	; 1
     29a:	49 f0       	breq	.+18     	; 0x2ae <TEMP_Tick+0x5a>
     29c:	0f c0       	rjmp	.+30     	; 0x2bc <TEMP_Tick+0x68>
     29e:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <ARM_DISARM>
     2a2:	81 11       	cpse	r24, r1
     2a4:	0d c0       	rjmp	.+26     	; 0x2c0 <TEMP_Tick+0x6c>
     2a6:	81 e0       	ldi	r24, 0x01	; 1
     2a8:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <temp_state>
     2ac:	08 95       	ret
     2ae:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <ARM_DISARM>
     2b2:	88 23       	and	r24, r24
     2b4:	29 f0       	breq	.+10     	; 0x2c0 <TEMP_Tick+0x6c>
     2b6:	10 92 99 07 	sts	0x0799, r1	; 0x800799 <temp_state>
     2ba:	08 95       	ret
     2bc:	10 92 99 07 	sts	0x0799, r1	; 0x800799 <temp_state>
     2c0:	08 95       	ret

000002c2 <TempSecTask>:
     2c2:	10 92 99 07 	sts	0x0799, r1	; 0x800799 <temp_state>
     2c6:	c6 df       	rcall	.-116    	; 0x254 <TEMP_Tick>
     2c8:	8a e0       	ldi	r24, 0x0A	; 10
     2ca:	90 e0       	ldi	r25, 0x00	; 0
     2cc:	d1 d6       	rcall	.+3490   	; 0x1070 <vTaskDelay>
     2ce:	fb cf       	rjmp	.-10     	; 0x2c6 <TempSecTask+0x4>

000002d0 <StartTempPulse>:
     2d0:	af 92       	push	r10
     2d2:	bf 92       	push	r11
     2d4:	cf 92       	push	r12
     2d6:	df 92       	push	r13
     2d8:	ef 92       	push	r14
     2da:	ff 92       	push	r15
     2dc:	0f 93       	push	r16
     2de:	a1 2c       	mov	r10, r1
     2e0:	b1 2c       	mov	r11, r1
     2e2:	c1 2c       	mov	r12, r1
     2e4:	d1 2c       	mov	r13, r1
     2e6:	e1 2c       	mov	r14, r1
     2e8:	f1 2c       	mov	r15, r1
     2ea:	08 2f       	mov	r16, r24
     2ec:	20 e0       	ldi	r18, 0x00	; 0
     2ee:	30 e0       	ldi	r19, 0x00	; 0
     2f0:	45 e5       	ldi	r20, 0x55	; 85
     2f2:	50 e0       	ldi	r21, 0x00	; 0
     2f4:	66 e1       	ldi	r22, 0x16	; 22
     2f6:	71 e0       	ldi	r23, 0x01	; 1
     2f8:	81 e6       	ldi	r24, 0x61	; 97
     2fa:	91 e0       	ldi	r25, 0x01	; 1
     2fc:	55 d4       	rcall	.+2218   	; 0xba8 <xTaskGenericCreate>
     2fe:	0f 91       	pop	r16
     300:	ff 90       	pop	r15
     302:	ef 90       	pop	r14
     304:	df 90       	pop	r13
     306:	cf 90       	pop	r12
     308:	bf 90       	pop	r11
     30a:	af 90       	pop	r10
     30c:	08 95       	ret

0000030e <ARM_Tick>:
     30e:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <arm_state>
     312:	88 23       	and	r24, r24
     314:	19 f0       	breq	.+6      	; 0x31c <ARM_Tick+0xe>
     316:	81 30       	cpi	r24, 0x01	; 1
     318:	61 f0       	breq	.+24     	; 0x332 <ARM_Tick+0x24>
     31a:	4f c0       	rjmp	.+158    	; 0x3ba <ARM_Tick+0xac>
     31c:	10 92 39 07 	sts	0x0739, r1	; 0x800739 <temp_trip>
     320:	10 92 38 07 	sts	0x0738, r1	; 0x800738 <IR_one_trip>
     324:	10 92 37 07 	sts	0x0737, r1	; 0x800737 <IR_two_trip>
     328:	10 92 36 07 	sts	0x0736, r1	; 0x800736 <button_one_trip>
     32c:	10 92 35 07 	sts	0x0735, r1	; 0x800735 <button_two_trip>
     330:	4b c0       	rjmp	.+150    	; 0x3c8 <ARM_Tick+0xba>
     332:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
     336:	30 91 79 00 	lds	r19, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
     33a:	22 0f       	add	r18, r18
     33c:	33 1f       	adc	r19, r19
     33e:	22 0f       	add	r18, r18
     340:	33 1f       	adc	r19, r19
     342:	30 93 3b 07 	sts	0x073B, r19	; 0x80073b <temp_MV+0x1>
     346:	20 93 3a 07 	sts	0x073A, r18	; 0x80073a <temp_MV>
     34a:	24 5f       	subi	r18, 0xF4	; 244
     34c:	31 40       	sbci	r19, 0x01	; 1
     34e:	ad ec       	ldi	r26, 0xCD	; 205
     350:	bc ec       	ldi	r27, 0xCC	; 204
     352:	4b d7       	rcall	.+3734   	; 0x11ea <__umulhisi3>
     354:	96 95       	lsr	r25
     356:	87 95       	ror	r24
     358:	96 95       	lsr	r25
     35a:	87 95       	ror	r24
     35c:	96 95       	lsr	r25
     35e:	87 95       	ror	r24
     360:	80 93 3c 07 	sts	0x073C, r24	; 0x80073c <temp_val>
     364:	1b b8       	out	0x0b, r1	; 11
     366:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <temp_val>
     36a:	80 32       	cpi	r24, 0x20	; 32
     36c:	20 f0       	brcs	.+8      	; 0x376 <ARM_Tick+0x68>
     36e:	81 e0       	ldi	r24, 0x01	; 1
     370:	80 93 39 07 	sts	0x0739, r24	; 0x800739 <temp_trip>
     374:	8b b9       	out	0x0b, r24	; 11
     376:	86 b1       	in	r24, 0x06	; 6
     378:	80 95       	com	r24
     37a:	83 ff       	sbrs	r24, 3
     37c:	05 c0       	rjmp	.+10     	; 0x388 <ARM_Tick+0x7a>
     37e:	81 e0       	ldi	r24, 0x01	; 1
     380:	80 93 37 07 	sts	0x0737, r24	; 0x800737 <IR_two_trip>
     384:	82 e0       	ldi	r24, 0x02	; 2
     386:	8b b9       	out	0x0b, r24	; 11
     388:	86 b1       	in	r24, 0x06	; 6
     38a:	80 95       	com	r24
     38c:	82 ff       	sbrs	r24, 2
     38e:	05 c0       	rjmp	.+10     	; 0x39a <ARM_Tick+0x8c>
     390:	81 e0       	ldi	r24, 0x01	; 1
     392:	80 93 38 07 	sts	0x0738, r24	; 0x800738 <IR_one_trip>
     396:	84 e0       	ldi	r24, 0x04	; 4
     398:	8b b9       	out	0x0b, r24	; 11
     39a:	86 b1       	in	r24, 0x06	; 6
     39c:	80 95       	com	r24
     39e:	81 ff       	sbrs	r24, 1
     3a0:	05 c0       	rjmp	.+10     	; 0x3ac <ARM_Tick+0x9e>
     3a2:	81 e0       	ldi	r24, 0x01	; 1
     3a4:	80 93 35 07 	sts	0x0735, r24	; 0x800735 <button_two_trip>
     3a8:	88 e0       	ldi	r24, 0x08	; 8
     3aa:	8b b9       	out	0x0b, r24	; 11
     3ac:	30 99       	sbic	0x06, 0	; 6
     3ae:	05 c0       	rjmp	.+10     	; 0x3ba <ARM_Tick+0xac>
     3b0:	81 e0       	ldi	r24, 0x01	; 1
     3b2:	80 93 36 07 	sts	0x0736, r24	; 0x800736 <button_one_trip>
     3b6:	80 e1       	ldi	r24, 0x10	; 16
     3b8:	8b b9       	out	0x0b, r24	; 11
     3ba:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <arm_state>
     3be:	88 23       	and	r24, r24
     3c0:	19 f0       	breq	.+6      	; 0x3c8 <ARM_Tick+0xba>
     3c2:	81 30       	cpi	r24, 0x01	; 1
     3c4:	41 f0       	breq	.+16     	; 0x3d6 <ARM_Tick+0xc8>
     3c6:	0e c0       	rjmp	.+28     	; 0x3e4 <ARM_Tick+0xd6>
     3c8:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <ARM_DISARM>
     3cc:	81 30       	cpi	r24, 0x01	; 1
     3ce:	61 f4       	brne	.+24     	; 0x3e8 <ARM_Tick+0xda>
     3d0:	80 93 9a 07 	sts	0x079A, r24	; 0x80079a <arm_state>
     3d4:	08 95       	ret
     3d6:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <ARM_DISARM>
     3da:	81 30       	cpi	r24, 0x01	; 1
     3dc:	29 f0       	breq	.+10     	; 0x3e8 <ARM_Tick+0xda>
     3de:	10 92 9a 07 	sts	0x079A, r1	; 0x80079a <arm_state>
     3e2:	08 95       	ret
     3e4:	10 92 9a 07 	sts	0x079A, r1	; 0x80079a <arm_state>
     3e8:	08 95       	ret

000003ea <ARMSecTask>:
     3ea:	10 92 9a 07 	sts	0x079A, r1	; 0x80079a <arm_state>
     3ee:	8f df       	rcall	.-226    	; 0x30e <ARM_Tick>
     3f0:	8a e0       	ldi	r24, 0x0A	; 10
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	3d d6       	rcall	.+3194   	; 0x1070 <vTaskDelay>
     3f6:	fb cf       	rjmp	.-10     	; 0x3ee <ARMSecTask+0x4>

000003f8 <StartARMPulse>:
     3f8:	af 92       	push	r10
     3fa:	bf 92       	push	r11
     3fc:	cf 92       	push	r12
     3fe:	df 92       	push	r13
     400:	ef 92       	push	r14
     402:	ff 92       	push	r15
     404:	0f 93       	push	r16
     406:	a1 2c       	mov	r10, r1
     408:	b1 2c       	mov	r11, r1
     40a:	c1 2c       	mov	r12, r1
     40c:	d1 2c       	mov	r13, r1
     40e:	e1 2c       	mov	r14, r1
     410:	f1 2c       	mov	r15, r1
     412:	08 2f       	mov	r16, r24
     414:	20 e0       	ldi	r18, 0x00	; 0
     416:	30 e0       	ldi	r19, 0x00	; 0
     418:	45 e5       	ldi	r20, 0x55	; 85
     41a:	50 e0       	ldi	r21, 0x00	; 0
     41c:	62 e2       	ldi	r22, 0x22	; 34
     41e:	71 e0       	ldi	r23, 0x01	; 1
     420:	85 ef       	ldi	r24, 0xF5	; 245
     422:	91 e0       	ldi	r25, 0x01	; 1
     424:	c1 d3       	rcall	.+1922   	; 0xba8 <xTaskGenericCreate>
     426:	0f 91       	pop	r16
     428:	ff 90       	pop	r15
     42a:	ef 90       	pop	r14
     42c:	df 90       	pop	r13
     42e:	cf 90       	pop	r12
     430:	bf 90       	pop	r11
     432:	af 90       	pop	r10
     434:	08 95       	ret

00000436 <Motor_Tick>:
     436:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <motor_state>
     43a:	81 30       	cpi	r24, 0x01	; 1
     43c:	89 f0       	breq	.+34     	; 0x460 <Motor_Tick+0x2a>
     43e:	20 f0       	brcs	.+8      	; 0x448 <Motor_Tick+0x12>
     440:	82 30       	cpi	r24, 0x02	; 2
     442:	09 f4       	brne	.+2      	; 0x446 <Motor_Tick+0x10>
     444:	69 c0       	rjmp	.+210    	; 0x518 <Motor_Tick+0xe2>
     446:	b6 c0       	rjmp	.+364    	; 0x5b4 <Motor_Tick+0x17e>
     448:	10 92 31 07 	sts	0x0731, r1	; 0x800731 <finished_reset_1>
     44c:	10 92 34 07 	sts	0x0734, r1	; 0x800734 <p_index>
     450:	10 92 33 07 	sts	0x0733, r1	; 0x800733 <numCounter+0x1>
     454:	10 92 32 07 	sts	0x0732, r1	; 0x800732 <numCounter>
     458:	81 e0       	ldi	r24, 0x01	; 1
     45a:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <orientation>
     45e:	b2 c0       	rjmp	.+356    	; 0x5c4 <Motor_Tick+0x18e>
     460:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <orientation>
     464:	88 23       	and	r24, r24
     466:	59 f1       	breq	.+86     	; 0x4be <Motor_Tick+0x88>
     468:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <numCounter>
     46c:	90 91 33 07 	lds	r25, 0x0733	; 0x800733 <numCounter+0x1>
     470:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <numPhases>
     474:	30 91 12 01 	lds	r19, 0x0112	; 0x800112 <numPhases+0x1>
     478:	82 17       	cp	r24, r18
     47a:	93 07       	cpc	r25, r19
     47c:	bc f4       	brge	.+46     	; 0x4ac <Motor_Tick+0x76>
     47e:	01 96       	adiw	r24, 0x01	; 1
     480:	90 93 33 07 	sts	0x0733, r25	; 0x800733 <numCounter+0x1>
     484:	80 93 32 07 	sts	0x0732, r24	; 0x800732 <numCounter>
     488:	e0 91 34 07 	lds	r30, 0x0734	; 0x800734 <p_index>
     48c:	f0 e0       	ldi	r31, 0x00	; 0
     48e:	e7 5f       	subi	r30, 0xF7	; 247
     490:	fe 4f       	sbci	r31, 0xFE	; 254
     492:	80 81       	ld	r24, Z
     494:	85 b9       	out	0x05, r24	; 5
     496:	80 91 34 07 	lds	r24, 0x0734	; 0x800734 <p_index>
     49a:	87 30       	cpi	r24, 0x07	; 7
     49c:	19 f4       	brne	.+6      	; 0x4a4 <Motor_Tick+0x6e>
     49e:	10 92 34 07 	sts	0x0734, r1	; 0x800734 <p_index>
     4a2:	88 c0       	rjmp	.+272    	; 0x5b4 <Motor_Tick+0x17e>
     4a4:	8f 5f       	subi	r24, 0xFF	; 255
     4a6:	80 93 34 07 	sts	0x0734, r24	; 0x800734 <p_index>
     4aa:	84 c0       	rjmp	.+264    	; 0x5b4 <Motor_Tick+0x17e>
     4ac:	10 92 33 07 	sts	0x0733, r1	; 0x800733 <numCounter+0x1>
     4b0:	10 92 32 07 	sts	0x0732, r1	; 0x800732 <numCounter>
     4b4:	10 92 08 01 	sts	0x0108, r1	; 0x800108 <orientation>
     4b8:	10 92 34 07 	sts	0x0734, r1	; 0x800734 <p_index>
     4bc:	8b c0       	rjmp	.+278    	; 0x5d4 <Motor_Tick+0x19e>
     4be:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <numCounter>
     4c2:	90 91 33 07 	lds	r25, 0x0733	; 0x800733 <numCounter+0x1>
     4c6:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <numPhases>
     4ca:	30 91 12 01 	lds	r19, 0x0112	; 0x800112 <numPhases+0x1>
     4ce:	82 17       	cp	r24, r18
     4d0:	93 07       	cpc	r25, r19
     4d2:	c4 f4       	brge	.+48     	; 0x504 <Motor_Tick+0xce>
     4d4:	01 96       	adiw	r24, 0x01	; 1
     4d6:	90 93 33 07 	sts	0x0733, r25	; 0x800733 <numCounter+0x1>
     4da:	80 93 32 07 	sts	0x0732, r24	; 0x800732 <numCounter>
     4de:	e0 91 34 07 	lds	r30, 0x0734	; 0x800734 <p_index>
     4e2:	f0 e0       	ldi	r31, 0x00	; 0
     4e4:	e7 5f       	subi	r30, 0xF7	; 247
     4e6:	fe 4f       	sbci	r31, 0xFE	; 254
     4e8:	80 81       	ld	r24, Z
     4ea:	85 b9       	out	0x05, r24	; 5
     4ec:	80 91 34 07 	lds	r24, 0x0734	; 0x800734 <p_index>
     4f0:	81 11       	cpse	r24, r1
     4f2:	04 c0       	rjmp	.+8      	; 0x4fc <Motor_Tick+0xc6>
     4f4:	87 e0       	ldi	r24, 0x07	; 7
     4f6:	80 93 34 07 	sts	0x0734, r24	; 0x800734 <p_index>
     4fa:	5c c0       	rjmp	.+184    	; 0x5b4 <Motor_Tick+0x17e>
     4fc:	81 50       	subi	r24, 0x01	; 1
     4fe:	80 93 34 07 	sts	0x0734, r24	; 0x800734 <p_index>
     502:	58 c0       	rjmp	.+176    	; 0x5b4 <Motor_Tick+0x17e>
     504:	10 92 33 07 	sts	0x0733, r1	; 0x800733 <numCounter+0x1>
     508:	10 92 32 07 	sts	0x0732, r1	; 0x800732 <numCounter>
     50c:	81 e0       	ldi	r24, 0x01	; 1
     50e:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <orientation>
     512:	10 92 34 07 	sts	0x0734, r1	; 0x800734 <p_index>
     516:	5e c0       	rjmp	.+188    	; 0x5d4 <Motor_Tick+0x19e>
     518:	80 91 08 01 	lds	r24, 0x0108	; 0x800108 <orientation>
     51c:	88 23       	and	r24, r24
     51e:	19 f1       	breq	.+70     	; 0x566 <Motor_Tick+0x130>
     520:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <numCounter>
     524:	90 91 33 07 	lds	r25, 0x0733	; 0x800733 <numCounter+0x1>
     528:	18 16       	cp	r1, r24
     52a:	19 06       	cpc	r1, r25
     52c:	c4 f4       	brge	.+48     	; 0x55e <Motor_Tick+0x128>
     52e:	01 97       	sbiw	r24, 0x01	; 1
     530:	90 93 33 07 	sts	0x0733, r25	; 0x800733 <numCounter+0x1>
     534:	80 93 32 07 	sts	0x0732, r24	; 0x800732 <numCounter>
     538:	e0 91 34 07 	lds	r30, 0x0734	; 0x800734 <p_index>
     53c:	f0 e0       	ldi	r31, 0x00	; 0
     53e:	e7 5f       	subi	r30, 0xF7	; 247
     540:	fe 4f       	sbci	r31, 0xFE	; 254
     542:	80 81       	ld	r24, Z
     544:	85 b9       	out	0x05, r24	; 5
     546:	80 91 34 07 	lds	r24, 0x0734	; 0x800734 <p_index>
     54a:	81 11       	cpse	r24, r1
     54c:	04 c0       	rjmp	.+8      	; 0x556 <Motor_Tick+0x120>
     54e:	87 e0       	ldi	r24, 0x07	; 7
     550:	80 93 34 07 	sts	0x0734, r24	; 0x800734 <p_index>
     554:	2f c0       	rjmp	.+94     	; 0x5b4 <Motor_Tick+0x17e>
     556:	81 50       	subi	r24, 0x01	; 1
     558:	80 93 34 07 	sts	0x0734, r24	; 0x800734 <p_index>
     55c:	2b c0       	rjmp	.+86     	; 0x5b4 <Motor_Tick+0x17e>
     55e:	81 e0       	ldi	r24, 0x01	; 1
     560:	80 93 31 07 	sts	0x0731, r24	; 0x800731 <finished_reset_1>
     564:	43 c0       	rjmp	.+134    	; 0x5ec <Motor_Tick+0x1b6>
     566:	80 91 32 07 	lds	r24, 0x0732	; 0x800732 <numCounter>
     56a:	90 91 33 07 	lds	r25, 0x0733	; 0x800733 <numCounter+0x1>
     56e:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <numPhases>
     572:	30 91 12 01 	lds	r19, 0x0112	; 0x800112 <numPhases+0x1>
     576:	82 17       	cp	r24, r18
     578:	93 07       	cpc	r25, r19
     57a:	c4 f4       	brge	.+48     	; 0x5ac <Motor_Tick+0x176>
     57c:	01 96       	adiw	r24, 0x01	; 1
     57e:	90 93 33 07 	sts	0x0733, r25	; 0x800733 <numCounter+0x1>
     582:	80 93 32 07 	sts	0x0732, r24	; 0x800732 <numCounter>
     586:	e0 91 34 07 	lds	r30, 0x0734	; 0x800734 <p_index>
     58a:	f0 e0       	ldi	r31, 0x00	; 0
     58c:	e7 5f       	subi	r30, 0xF7	; 247
     58e:	fe 4f       	sbci	r31, 0xFE	; 254
     590:	80 81       	ld	r24, Z
     592:	85 b9       	out	0x05, r24	; 5
     594:	80 91 34 07 	lds	r24, 0x0734	; 0x800734 <p_index>
     598:	81 11       	cpse	r24, r1
     59a:	04 c0       	rjmp	.+8      	; 0x5a4 <Motor_Tick+0x16e>
     59c:	87 e0       	ldi	r24, 0x07	; 7
     59e:	80 93 34 07 	sts	0x0734, r24	; 0x800734 <p_index>
     5a2:	08 c0       	rjmp	.+16     	; 0x5b4 <Motor_Tick+0x17e>
     5a4:	81 50       	subi	r24, 0x01	; 1
     5a6:	80 93 34 07 	sts	0x0734, r24	; 0x800734 <p_index>
     5aa:	04 c0       	rjmp	.+8      	; 0x5b4 <Motor_Tick+0x17e>
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	80 93 31 07 	sts	0x0731, r24	; 0x800731 <finished_reset_1>
     5b2:	1c c0       	rjmp	.+56     	; 0x5ec <Motor_Tick+0x1b6>
     5b4:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <motor_state>
     5b8:	81 30       	cpi	r24, 0x01	; 1
     5ba:	61 f0       	breq	.+24     	; 0x5d4 <Motor_Tick+0x19e>
     5bc:	18 f0       	brcs	.+6      	; 0x5c4 <Motor_Tick+0x18e>
     5be:	82 30       	cpi	r24, 0x02	; 2
     5c0:	c1 f4       	brne	.+48     	; 0x5f2 <Motor_Tick+0x1bc>
     5c2:	10 c0       	rjmp	.+32     	; 0x5e4 <Motor_Tick+0x1ae>
     5c4:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <ARM_DISARM>
     5c8:	88 23       	and	r24, r24
     5ca:	a9 f0       	breq	.+42     	; 0x5f6 <Motor_Tick+0x1c0>
     5cc:	81 e0       	ldi	r24, 0x01	; 1
     5ce:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <motor_state>
     5d2:	08 95       	ret
     5d4:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <ARM_DISARM>
     5d8:	81 30       	cpi	r24, 0x01	; 1
     5da:	69 f0       	breq	.+26     	; 0x5f6 <Motor_Tick+0x1c0>
     5dc:	82 e0       	ldi	r24, 0x02	; 2
     5de:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <motor_state>
     5e2:	08 95       	ret
     5e4:	80 91 31 07 	lds	r24, 0x0731	; 0x800731 <finished_reset_1>
     5e8:	81 30       	cpi	r24, 0x01	; 1
     5ea:	29 f4       	brne	.+10     	; 0x5f6 <Motor_Tick+0x1c0>
     5ec:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <motor_state>
     5f0:	08 95       	ret
     5f2:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <motor_state>
     5f6:	08 95       	ret

000005f8 <MotorSecTask>:
     5f8:	81 e0       	ldi	r24, 0x01	; 1
     5fa:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <motor_state>
     5fe:	1b df       	rcall	.-458    	; 0x436 <Motor_Tick>
     600:	83 e0       	ldi	r24, 0x03	; 3
     602:	90 e0       	ldi	r25, 0x00	; 0
     604:	35 d5       	rcall	.+2666   	; 0x1070 <vTaskDelay>
     606:	fb cf       	rjmp	.-10     	; 0x5fe <MotorSecTask+0x6>

00000608 <MotorSecPulse>:
     608:	af 92       	push	r10
     60a:	bf 92       	push	r11
     60c:	cf 92       	push	r12
     60e:	df 92       	push	r13
     610:	ef 92       	push	r14
     612:	ff 92       	push	r15
     614:	0f 93       	push	r16
     616:	a1 2c       	mov	r10, r1
     618:	b1 2c       	mov	r11, r1
     61a:	c1 2c       	mov	r12, r1
     61c:	d1 2c       	mov	r13, r1
     61e:	e1 2c       	mov	r14, r1
     620:	f1 2c       	mov	r15, r1
     622:	08 2f       	mov	r16, r24
     624:	20 e0       	ldi	r18, 0x00	; 0
     626:	30 e0       	ldi	r19, 0x00	; 0
     628:	45 e5       	ldi	r20, 0x55	; 85
     62a:	50 e0       	ldi	r21, 0x00	; 0
     62c:	6d e2       	ldi	r22, 0x2D	; 45
     62e:	71 e0       	ldi	r23, 0x01	; 1
     630:	8c ef       	ldi	r24, 0xFC	; 252
     632:	92 e0       	ldi	r25, 0x02	; 2
     634:	b9 d2       	rcall	.+1394   	; 0xba8 <xTaskGenericCreate>
     636:	0f 91       	pop	r16
     638:	ff 90       	pop	r15
     63a:	ef 90       	pop	r14
     63c:	df 90       	pop	r13
     63e:	cf 90       	pop	r12
     640:	bf 90       	pop	r11
     642:	af 90       	pop	r10
     644:	08 95       	ret

00000646 <Motor_Tick_2>:
}

void Motor_Tick_2(){
	//Actions
	switch(motor_state_2){
     646:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <motor_state_2>
     64a:	81 30       	cpi	r24, 0x01	; 1
     64c:	81 f0       	breq	.+32     	; 0x66e <Motor_Tick_2+0x28>
     64e:	20 f0       	brcs	.+8      	; 0x658 <Motor_Tick_2+0x12>
     650:	82 30       	cpi	r24, 0x02	; 2
     652:	09 f4       	brne	.+2      	; 0x656 <Motor_Tick_2+0x10>
     654:	6c c0       	rjmp	.+216    	; 0x72e <Motor_Tick_2+0xe8>
     656:	bb c0       	rjmp	.+374    	; 0x7ce <Motor_Tick_2+0x188>
		case m_wait_2:
		//reset to original values
		finished_reset_2 = 0;
     658:	10 92 2c 07 	sts	0x072C, r1	; 0x80072c <finished_reset_2>
		p_index_2 = 0;
     65c:	10 92 2f 07 	sts	0x072F, r1	; 0x80072f <p_index_2>
		numCounter_2 = 0;
     660:	10 92 2e 07 	sts	0x072E, r1	; 0x80072e <numCounter_2+0x1>
     664:	10 92 2d 07 	sts	0x072D, r1	; 0x80072d <numCounter_2>
		orientation_2 = 0;
     668:	10 92 30 07 	sts	0x0730, r1	; 0x800730 <orientation_2>
     66c:	b8 c0       	rjmp	.+368    	; 0x7de <Motor_Tick_2+0x198>
		break;

		case m_init_2:
		if(orientation_2){ //forward orientation == 1
     66e:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <orientation_2>
     672:	88 23       	and	r24, r24
     674:	69 f1       	breq	.+90     	; 0x6d0 <Motor_Tick_2+0x8a>
			if(numCounter_2 < numPhases){
     676:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <numCounter_2>
     67a:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <numCounter_2+0x1>
     67e:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <numPhases>
     682:	30 91 12 01 	lds	r19, 0x0112	; 0x800112 <numPhases+0x1>
     686:	82 17       	cp	r24, r18
     688:	93 07       	cpc	r25, r19
     68a:	cc f4       	brge	.+50     	; 0x6be <Motor_Tick_2+0x78>
				++numCounter_2;
     68c:	01 96       	adiw	r24, 0x01	; 1
     68e:	90 93 2e 07 	sts	0x072E, r25	; 0x80072e <numCounter_2+0x1>
     692:	80 93 2d 07 	sts	0x072D, r24	; 0x80072d <numCounter_2>
				PORTB = PORTB | phases_2[p_index_2];
     696:	95 b1       	in	r25, 0x05	; 5
     698:	e0 91 2f 07 	lds	r30, 0x072F	; 0x80072f <p_index_2>
     69c:	f0 e0       	ldi	r31, 0x00	; 0
     69e:	e0 50       	subi	r30, 0x00	; 0
     6a0:	ff 4f       	sbci	r31, 0xFF	; 255
     6a2:	80 81       	ld	r24, Z
     6a4:	89 2b       	or	r24, r25
     6a6:	85 b9       	out	0x05, r24	; 5
				
				if(p_index_2 == 7){
     6a8:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <p_index_2>
     6ac:	87 30       	cpi	r24, 0x07	; 7
     6ae:	19 f4       	brne	.+6      	; 0x6b6 <Motor_Tick_2+0x70>
					p_index_2 = 0;
     6b0:	10 92 2f 07 	sts	0x072F, r1	; 0x80072f <p_index_2>
     6b4:	8c c0       	rjmp	.+280    	; 0x7ce <Motor_Tick_2+0x188>
				}
				
				else{
					++p_index_2;
     6b6:	8f 5f       	subi	r24, 0xFF	; 255
     6b8:	80 93 2f 07 	sts	0x072F, r24	; 0x80072f <p_index_2>
     6bc:	88 c0       	rjmp	.+272    	; 0x7ce <Motor_Tick_2+0x188>
				}
			}
			
			else{
				numCounter_2 = 0;
     6be:	10 92 2e 07 	sts	0x072E, r1	; 0x80072e <numCounter_2+0x1>
     6c2:	10 92 2d 07 	sts	0x072D, r1	; 0x80072d <numCounter_2>
				orientation_2 = 0;
     6c6:	10 92 30 07 	sts	0x0730, r1	; 0x800730 <orientation_2>
				p_index_2 = 0;
     6ca:	10 92 2f 07 	sts	0x072F, r1	; 0x80072f <p_index_2>
     6ce:	8f c0       	rjmp	.+286    	; 0x7ee <Motor_Tick_2+0x1a8>
			}
			
		}
		
		else{ //orientation == 0 go forwards
			if(numCounter_2 < numPhases){
     6d0:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <numCounter_2>
     6d4:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <numCounter_2+0x1>
     6d8:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <numPhases>
     6dc:	30 91 12 01 	lds	r19, 0x0112	; 0x800112 <numPhases+0x1>
     6e0:	82 17       	cp	r24, r18
     6e2:	93 07       	cpc	r25, r19
     6e4:	d4 f4       	brge	.+52     	; 0x71a <Motor_Tick_2+0xd4>
				++numCounter_2;
     6e6:	01 96       	adiw	r24, 0x01	; 1
     6e8:	90 93 2e 07 	sts	0x072E, r25	; 0x80072e <numCounter_2+0x1>
     6ec:	80 93 2d 07 	sts	0x072D, r24	; 0x80072d <numCounter_2>
				PORTB = PORTB | phases_2[p_index_2];
     6f0:	95 b1       	in	r25, 0x05	; 5
     6f2:	e0 91 2f 07 	lds	r30, 0x072F	; 0x80072f <p_index_2>
     6f6:	f0 e0       	ldi	r31, 0x00	; 0
     6f8:	e0 50       	subi	r30, 0x00	; 0
     6fa:	ff 4f       	sbci	r31, 0xFF	; 255
     6fc:	80 81       	ld	r24, Z
     6fe:	89 2b       	or	r24, r25
     700:	85 b9       	out	0x05, r24	; 5
				
				if(p_index_2 == 0){
     702:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <p_index_2>
     706:	81 11       	cpse	r24, r1
     708:	04 c0       	rjmp	.+8      	; 0x712 <Motor_Tick_2+0xcc>
					p_index_2 = 7;
     70a:	87 e0       	ldi	r24, 0x07	; 7
     70c:	80 93 2f 07 	sts	0x072F, r24	; 0x80072f <p_index_2>
     710:	5e c0       	rjmp	.+188    	; 0x7ce <Motor_Tick_2+0x188>
				}
				
				else{
					--p_index_2;
     712:	81 50       	subi	r24, 0x01	; 1
     714:	80 93 2f 07 	sts	0x072F, r24	; 0x80072f <p_index_2>
     718:	5a c0       	rjmp	.+180    	; 0x7ce <Motor_Tick_2+0x188>
				}
			}
			
			else{
				numCounter_2 = 0;
     71a:	10 92 2e 07 	sts	0x072E, r1	; 0x80072e <numCounter_2+0x1>
     71e:	10 92 2d 07 	sts	0x072D, r1	; 0x80072d <numCounter_2>
				orientation_2 = 1;
     722:	81 e0       	ldi	r24, 0x01	; 1
     724:	80 93 30 07 	sts	0x0730, r24	; 0x800730 <orientation_2>
				p_index_2 = 0;
     728:	10 92 2f 07 	sts	0x072F, r1	; 0x80072f <p_index_2>
     72c:	60 c0       	rjmp	.+192    	; 0x7ee <Motor_Tick_2+0x1a8>
		}
		
		break;

		case m_reset_2:
		if(orientation_2 == 0){ //going forward return to reset
     72e:	80 91 30 07 	lds	r24, 0x0730	; 0x800730 <orientation_2>
     732:	81 11       	cpse	r24, r1
     734:	24 c0       	rjmp	.+72     	; 0x77e <Motor_Tick_2+0x138>
			if(numCounter_2 > 0){
     736:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <numCounter_2>
     73a:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <numCounter_2+0x1>
     73e:	18 16       	cp	r1, r24
     740:	19 06       	cpc	r1, r25
     742:	cc f4       	brge	.+50     	; 0x776 <Motor_Tick_2+0x130>
				--numCounter_2;
     744:	01 97       	sbiw	r24, 0x01	; 1
     746:	90 93 2e 07 	sts	0x072E, r25	; 0x80072e <numCounter_2+0x1>
     74a:	80 93 2d 07 	sts	0x072D, r24	; 0x80072d <numCounter_2>
				PORTB = PORTB | phases_2[p_index_2];
     74e:	95 b1       	in	r25, 0x05	; 5
     750:	e0 91 2f 07 	lds	r30, 0x072F	; 0x80072f <p_index_2>
     754:	f0 e0       	ldi	r31, 0x00	; 0
     756:	e0 50       	subi	r30, 0x00	; 0
     758:	ff 4f       	sbci	r31, 0xFF	; 255
     75a:	80 81       	ld	r24, Z
     75c:	89 2b       	or	r24, r25
     75e:	85 b9       	out	0x05, r24	; 5
				
				if(p_index_2 == 7){
     760:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <p_index_2>
     764:	87 30       	cpi	r24, 0x07	; 7
     766:	19 f4       	brne	.+6      	; 0x76e <Motor_Tick_2+0x128>
					p_index_2 = 0;
     768:	10 92 2f 07 	sts	0x072F, r1	; 0x80072f <p_index_2>
     76c:	30 c0       	rjmp	.+96     	; 0x7ce <Motor_Tick_2+0x188>
				}
				
				else{
					++p_index_2;
     76e:	8f 5f       	subi	r24, 0xFF	; 255
     770:	80 93 2f 07 	sts	0x072F, r24	; 0x80072f <p_index_2>
     774:	2c c0       	rjmp	.+88     	; 0x7ce <Motor_Tick_2+0x188>
				}

			}

			else{
				finished_reset_2 = 1; //done with reset
     776:	81 e0       	ldi	r24, 0x01	; 1
     778:	80 93 2c 07 	sts	0x072C, r24	; 0x80072c <finished_reset_2>
     77c:	44 c0       	rjmp	.+136    	; 0x806 <Motor_Tick_2+0x1c0>
			}
		}

		else{ //motor going back continue to reset position
			if(numCounter_2 < numPhases){
     77e:	80 91 2d 07 	lds	r24, 0x072D	; 0x80072d <numCounter_2>
     782:	90 91 2e 07 	lds	r25, 0x072E	; 0x80072e <numCounter_2+0x1>
     786:	20 91 11 01 	lds	r18, 0x0111	; 0x800111 <numPhases>
     78a:	30 91 12 01 	lds	r19, 0x0112	; 0x800112 <numPhases+0x1>
     78e:	82 17       	cp	r24, r18
     790:	93 07       	cpc	r25, r19
     792:	cc f4       	brge	.+50     	; 0x7c6 <Motor_Tick_2+0x180>
				++ numCounter_2;
     794:	01 96       	adiw	r24, 0x01	; 1
     796:	90 93 2e 07 	sts	0x072E, r25	; 0x80072e <numCounter_2+0x1>
     79a:	80 93 2d 07 	sts	0x072D, r24	; 0x80072d <numCounter_2>
				PORTB = PORTB | phases_2[p_index_2];
     79e:	95 b1       	in	r25, 0x05	; 5
     7a0:	e0 91 2f 07 	lds	r30, 0x072F	; 0x80072f <p_index_2>
     7a4:	f0 e0       	ldi	r31, 0x00	; 0
     7a6:	e0 50       	subi	r30, 0x00	; 0
     7a8:	ff 4f       	sbci	r31, 0xFF	; 255
     7aa:	80 81       	ld	r24, Z
     7ac:	89 2b       	or	r24, r25
     7ae:	85 b9       	out	0x05, r24	; 5
				
				if(p_index_2 == 7){
     7b0:	80 91 2f 07 	lds	r24, 0x072F	; 0x80072f <p_index_2>
     7b4:	87 30       	cpi	r24, 0x07	; 7
     7b6:	19 f4       	brne	.+6      	; 0x7be <Motor_Tick_2+0x178>
					p_index_2 = 0;
     7b8:	10 92 2f 07 	sts	0x072F, r1	; 0x80072f <p_index_2>
     7bc:	08 c0       	rjmp	.+16     	; 0x7ce <Motor_Tick_2+0x188>
				}
				
				else{
					++p_index_2;
     7be:	8f 5f       	subi	r24, 0xFF	; 255
     7c0:	80 93 2f 07 	sts	0x072F, r24	; 0x80072f <p_index_2>
     7c4:	04 c0       	rjmp	.+8      	; 0x7ce <Motor_Tick_2+0x188>
				}

			}

			else{
				finished_reset_2 = 1; //done with reset
     7c6:	81 e0       	ldi	r24, 0x01	; 1
     7c8:	80 93 2c 07 	sts	0x072C, r24	; 0x80072c <finished_reset_2>
     7cc:	1c c0       	rjmp	.+56     	; 0x806 <Motor_Tick_2+0x1c0>
		
		default:
		break;
	}
	//Transitions
	switch(motor_state_2){
     7ce:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <motor_state_2>
     7d2:	81 30       	cpi	r24, 0x01	; 1
     7d4:	61 f0       	breq	.+24     	; 0x7ee <Motor_Tick_2+0x1a8>
     7d6:	18 f0       	brcs	.+6      	; 0x7de <Motor_Tick_2+0x198>
     7d8:	82 30       	cpi	r24, 0x02	; 2
     7da:	c1 f4       	brne	.+48     	; 0x80c <Motor_Tick_2+0x1c6>
     7dc:	10 c0       	rjmp	.+32     	; 0x7fe <Motor_Tick_2+0x1b8>
		case m_wait_2:
		if(ARM_DISARM == 0){ //if system disarmed motor off
     7de:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <ARM_DISARM>
     7e2:	88 23       	and	r24, r24
     7e4:	a9 f0       	breq	.+42     	; 0x810 <Motor_Tick_2+0x1ca>
			motor_state_2 = m_wait_2;
		}
		else{ //else turn on motors
			motor_state_2 = m_init_2;
     7e6:	81 e0       	ldi	r24, 0x01	; 1
     7e8:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <motor_state_2>
     7ec:	08 95       	ret
		}
		break;

		case m_init_2:
		if(ARM_DISARM == 1){ //if system armed motor on
     7ee:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <ARM_DISARM>
     7f2:	81 30       	cpi	r24, 0x01	; 1
     7f4:	69 f0       	breq	.+26     	; 0x810 <Motor_Tick_2+0x1ca>
			motor_state_2 = m_init_2;
		}
		else{
			motor_state_2 = m_reset_2;
     7f6:	82 e0       	ldi	r24, 0x02	; 2
     7f8:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <motor_state_2>
     7fc:	08 95       	ret
		}
		break;

		case m_reset_2:
		if(finished_reset_2 == 1){ //finished reset
     7fe:	80 91 2c 07 	lds	r24, 0x072C	; 0x80072c <finished_reset_2>
     802:	81 30       	cpi	r24, 0x01	; 1
     804:	29 f4       	brne	.+10     	; 0x810 <Motor_Tick_2+0x1ca>
			motor_state_2 = m_wait_2;
     806:	10 92 98 07 	sts	0x0798, r1	; 0x800798 <motor_state_2>
     80a:	08 95       	ret
			motor_state_2 = m_reset_2;
		}
		break;
		
		default:
		motor_state_2 = m_wait_2;
     80c:	10 92 98 07 	sts	0x0798, r1	; 0x800798 <motor_state_2>
     810:	08 95       	ret

00000812 <MotorSecTask_2>:
//MOTOR 2 FSM
enum MotorState_2 {m_wait_2, m_init_2, m_reset_2} motor_state_2;


void Motor_2_Init(){
	motor_state_2 = m_init_2;
     812:	81 e0       	ldi	r24, 0x01	; 1
     814:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <motor_state_2>
{
	Motor_2_Init();
	for(;;)
	{
		Motor_Tick_2();
		vTaskDelay(3);
     818:	16 df       	rcall	.-468    	; 0x646 <Motor_Tick_2>
     81a:	83 e0       	ldi	r24, 0x03	; 3
     81c:	90 e0       	ldi	r25, 0x00	; 0
     81e:	28 d4       	rcall	.+2128   	; 0x1070 <vTaskDelay>
     820:	fb cf       	rjmp	.-10     	; 0x818 <MotorSecTask_2+0x6>

00000822 <Motor2SecPulse>:
	}
}

void Motor2SecPulse(unsigned portBASE_TYPE Priority)
{
     822:	af 92       	push	r10
     824:	bf 92       	push	r11
     826:	cf 92       	push	r12
     828:	df 92       	push	r13
     82a:	ef 92       	push	r14
     82c:	ff 92       	push	r15
     82e:	0f 93       	push	r16
	xTaskCreate(MotorSecTask_2, (signed portCHAR *)"MotorSecTask_2", configMINIMAL_STACK_SIZE, NULL, Priority, NULL );
     830:	a1 2c       	mov	r10, r1
     832:	b1 2c       	mov	r11, r1
     834:	c1 2c       	mov	r12, r1
     836:	d1 2c       	mov	r13, r1
     838:	e1 2c       	mov	r14, r1
     83a:	f1 2c       	mov	r15, r1
     83c:	08 2f       	mov	r16, r24
     83e:	20 e0       	ldi	r18, 0x00	; 0
     840:	30 e0       	ldi	r19, 0x00	; 0
     842:	45 e5       	ldi	r20, 0x55	; 85
     844:	50 e0       	ldi	r21, 0x00	; 0
     846:	6a e3       	ldi	r22, 0x3A	; 58
     848:	71 e0       	ldi	r23, 0x01	; 1
     84a:	89 e0       	ldi	r24, 0x09	; 9
     84c:	94 e0       	ldi	r25, 0x04	; 4
     84e:	ac d1       	rcall	.+856    	; 0xba8 <xTaskGenericCreate>
}
     850:	0f 91       	pop	r16
     852:	ff 90       	pop	r15
     854:	ef 90       	pop	r14
     856:	df 90       	pop	r13
     858:	cf 90       	pop	r12
     85a:	bf 90       	pop	r11
     85c:	af 90       	pop	r10
     85e:	08 95       	ret

00000860 <main>:

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////

 
int main(void) 
{ 
     860:	f3 dc       	rcall	.-1562   	; 0x248 <ADC_init>
     862:	11 b8       	out	0x01, r1	; 1
     864:	8f ef       	ldi	r24, 0xFF	; 255
     866:	82 b9       	out	0x02, r24	; 2
     868:	84 b9       	out	0x04, r24	; 4
     86a:	15 b8       	out	0x05, r1	; 5
     86c:	17 b8       	out	0x07, r1	; 7
     86e:	88 b9       	out	0x08, r24	; 8
     870:	8a b9       	out	0x0a, r24	; 10
     872:	1b b8       	out	0x0b, r1	; 11
     874:	81 e0       	ldi	r24, 0x01	; 1
     876:	c8 de       	rcall	.-624    	; 0x608 <MotorSecPulse>
     878:	81 e0       	ldi	r24, 0x01	; 1
     87a:	d3 df       	rcall	.-90     	; 0x822 <Motor2SecPulse>
     87c:	81 e0       	ldi	r24, 0x01	; 1
     87e:	28 dd       	rcall	.-1456   	; 0x2d0 <StartTempPulse>
     880:	81 e0       	ldi	r24, 0x01	; 1
     882:	ba dd       	rcall	.-1164   	; 0x3f8 <StartARMPulse>
     884:	84 d2       	rcall	.+1288   	; 0xd8e <vTaskStartScheduler>
     886:	80 e0       	ldi	r24, 0x00	; 0
     888:	90 e0       	ldi	r25, 0x00	; 0
     88a:	08 95       	ret

0000088c <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
     88c:	31 e1       	ldi	r19, 0x11	; 17
     88e:	fc 01       	movw	r30, r24
     890:	30 83       	st	Z, r19
     892:	31 97       	sbiw	r30, 0x01	; 1
     894:	22 e2       	ldi	r18, 0x22	; 34
     896:	20 83       	st	Z, r18
     898:	31 97       	sbiw	r30, 0x01	; 1
     89a:	a3 e3       	ldi	r26, 0x33	; 51
     89c:	a0 83       	st	Z, r26
     89e:	31 97       	sbiw	r30, 0x01	; 1
     8a0:	60 83       	st	Z, r22
     8a2:	31 97       	sbiw	r30, 0x01	; 1
     8a4:	70 83       	st	Z, r23
     8a6:	31 97       	sbiw	r30, 0x01	; 1
     8a8:	10 82       	st	Z, r1
     8aa:	31 97       	sbiw	r30, 0x01	; 1
     8ac:	60 e8       	ldi	r22, 0x80	; 128
     8ae:	60 83       	st	Z, r22
     8b0:	31 97       	sbiw	r30, 0x01	; 1
     8b2:	10 82       	st	Z, r1
     8b4:	31 97       	sbiw	r30, 0x01	; 1
     8b6:	62 e0       	ldi	r22, 0x02	; 2
     8b8:	60 83       	st	Z, r22
     8ba:	31 97       	sbiw	r30, 0x01	; 1
     8bc:	63 e0       	ldi	r22, 0x03	; 3
     8be:	60 83       	st	Z, r22
     8c0:	31 97       	sbiw	r30, 0x01	; 1
     8c2:	64 e0       	ldi	r22, 0x04	; 4
     8c4:	60 83       	st	Z, r22
     8c6:	31 97       	sbiw	r30, 0x01	; 1
     8c8:	65 e0       	ldi	r22, 0x05	; 5
     8ca:	60 83       	st	Z, r22
     8cc:	31 97       	sbiw	r30, 0x01	; 1
     8ce:	66 e0       	ldi	r22, 0x06	; 6
     8d0:	60 83       	st	Z, r22
     8d2:	31 97       	sbiw	r30, 0x01	; 1
     8d4:	67 e0       	ldi	r22, 0x07	; 7
     8d6:	60 83       	st	Z, r22
     8d8:	31 97       	sbiw	r30, 0x01	; 1
     8da:	68 e0       	ldi	r22, 0x08	; 8
     8dc:	60 83       	st	Z, r22
     8de:	31 97       	sbiw	r30, 0x01	; 1
     8e0:	69 e0       	ldi	r22, 0x09	; 9
     8e2:	60 83       	st	Z, r22
     8e4:	31 97       	sbiw	r30, 0x01	; 1
     8e6:	60 e1       	ldi	r22, 0x10	; 16
     8e8:	60 83       	st	Z, r22
     8ea:	31 97       	sbiw	r30, 0x01	; 1
     8ec:	30 83       	st	Z, r19
     8ee:	31 97       	sbiw	r30, 0x01	; 1
     8f0:	32 e1       	ldi	r19, 0x12	; 18
     8f2:	30 83       	st	Z, r19
     8f4:	31 97       	sbiw	r30, 0x01	; 1
     8f6:	33 e1       	ldi	r19, 0x13	; 19
     8f8:	30 83       	st	Z, r19
     8fa:	31 97       	sbiw	r30, 0x01	; 1
     8fc:	34 e1       	ldi	r19, 0x14	; 20
     8fe:	30 83       	st	Z, r19
     900:	31 97       	sbiw	r30, 0x01	; 1
     902:	35 e1       	ldi	r19, 0x15	; 21
     904:	30 83       	st	Z, r19
     906:	31 97       	sbiw	r30, 0x01	; 1
     908:	36 e1       	ldi	r19, 0x16	; 22
     90a:	30 83       	st	Z, r19
     90c:	31 97       	sbiw	r30, 0x01	; 1
     90e:	37 e1       	ldi	r19, 0x17	; 23
     910:	30 83       	st	Z, r19
     912:	31 97       	sbiw	r30, 0x01	; 1
     914:	38 e1       	ldi	r19, 0x18	; 24
     916:	30 83       	st	Z, r19
     918:	31 97       	sbiw	r30, 0x01	; 1
     91a:	39 e1       	ldi	r19, 0x19	; 25
     91c:	30 83       	st	Z, r19
     91e:	31 97       	sbiw	r30, 0x01	; 1
     920:	30 e2       	ldi	r19, 0x20	; 32
     922:	30 83       	st	Z, r19
     924:	31 97       	sbiw	r30, 0x01	; 1
     926:	31 e2       	ldi	r19, 0x21	; 33
     928:	30 83       	st	Z, r19
     92a:	31 97       	sbiw	r30, 0x01	; 1
     92c:	20 83       	st	Z, r18
     92e:	31 97       	sbiw	r30, 0x01	; 1
     930:	23 e2       	ldi	r18, 0x23	; 35
     932:	20 83       	st	Z, r18
     934:	31 97       	sbiw	r30, 0x01	; 1
     936:	40 83       	st	Z, r20
     938:	31 97       	sbiw	r30, 0x01	; 1
     93a:	50 83       	st	Z, r21
     93c:	31 97       	sbiw	r30, 0x01	; 1
     93e:	26 e2       	ldi	r18, 0x26	; 38
     940:	20 83       	st	Z, r18
     942:	31 97       	sbiw	r30, 0x01	; 1
     944:	27 e2       	ldi	r18, 0x27	; 39
     946:	20 83       	st	Z, r18
     948:	31 97       	sbiw	r30, 0x01	; 1
     94a:	28 e2       	ldi	r18, 0x28	; 40
     94c:	20 83       	st	Z, r18
     94e:	31 97       	sbiw	r30, 0x01	; 1
     950:	29 e2       	ldi	r18, 0x29	; 41
     952:	20 83       	st	Z, r18
     954:	31 97       	sbiw	r30, 0x01	; 1
     956:	20 e3       	ldi	r18, 0x30	; 48
     958:	20 83       	st	Z, r18
     95a:	31 97       	sbiw	r30, 0x01	; 1
     95c:	21 e3       	ldi	r18, 0x31	; 49
     95e:	20 83       	st	Z, r18
     960:	86 97       	sbiw	r24, 0x26	; 38
     962:	08 95       	ret

00000964 <xPortStartScheduler>:
     964:	10 92 89 00 	sts	0x0089, r1	; 0x800089 <__TEXT_REGION_LENGTH__+0x7e0089>
     968:	8c e7       	ldi	r24, 0x7C	; 124
     96a:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x7e0088>
     96e:	8b e0       	ldi	r24, 0x0B	; 11
     970:	80 93 81 00 	sts	0x0081, r24	; 0x800081 <__TEXT_REGION_LENGTH__+0x7e0081>
     974:	ef e6       	ldi	r30, 0x6F	; 111
     976:	f0 e0       	ldi	r31, 0x00	; 0
     978:	80 81       	ld	r24, Z
     97a:	82 60       	ori	r24, 0x02	; 2
     97c:	80 83       	st	Z, r24
     97e:	a0 91 95 07 	lds	r26, 0x0795	; 0x800795 <pxCurrentTCB>
     982:	b0 91 96 07 	lds	r27, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     986:	cd 91       	ld	r28, X+
     988:	cd bf       	out	0x3d, r28	; 61
     98a:	dd 91       	ld	r29, X+
     98c:	de bf       	out	0x3e, r29	; 62
     98e:	ff 91       	pop	r31
     990:	ef 91       	pop	r30
     992:	df 91       	pop	r29
     994:	cf 91       	pop	r28
     996:	bf 91       	pop	r27
     998:	af 91       	pop	r26
     99a:	9f 91       	pop	r25
     99c:	8f 91       	pop	r24
     99e:	7f 91       	pop	r23
     9a0:	6f 91       	pop	r22
     9a2:	5f 91       	pop	r21
     9a4:	4f 91       	pop	r20
     9a6:	3f 91       	pop	r19
     9a8:	2f 91       	pop	r18
     9aa:	1f 91       	pop	r17
     9ac:	0f 91       	pop	r16
     9ae:	ff 90       	pop	r15
     9b0:	ef 90       	pop	r14
     9b2:	df 90       	pop	r13
     9b4:	cf 90       	pop	r12
     9b6:	bf 90       	pop	r11
     9b8:	af 90       	pop	r10
     9ba:	9f 90       	pop	r9
     9bc:	8f 90       	pop	r8
     9be:	7f 90       	pop	r7
     9c0:	6f 90       	pop	r6
     9c2:	5f 90       	pop	r5
     9c4:	4f 90       	pop	r4
     9c6:	3f 90       	pop	r3
     9c8:	2f 90       	pop	r2
     9ca:	1f 90       	pop	r1
     9cc:	0f 90       	pop	r0
     9ce:	0f be       	out	0x3f, r0	; 63
     9d0:	0f 90       	pop	r0
     9d2:	08 95       	ret
     9d4:	81 e0       	ldi	r24, 0x01	; 1
     9d6:	08 95       	ret

000009d8 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
     9d8:	0f 92       	push	r0
     9da:	0f b6       	in	r0, 0x3f	; 63
     9dc:	f8 94       	cli
     9de:	0f 92       	push	r0
     9e0:	1f 92       	push	r1
     9e2:	11 24       	eor	r1, r1
     9e4:	2f 92       	push	r2
     9e6:	3f 92       	push	r3
     9e8:	4f 92       	push	r4
     9ea:	5f 92       	push	r5
     9ec:	6f 92       	push	r6
     9ee:	7f 92       	push	r7
     9f0:	8f 92       	push	r8
     9f2:	9f 92       	push	r9
     9f4:	af 92       	push	r10
     9f6:	bf 92       	push	r11
     9f8:	cf 92       	push	r12
     9fa:	df 92       	push	r13
     9fc:	ef 92       	push	r14
     9fe:	ff 92       	push	r15
     a00:	0f 93       	push	r16
     a02:	1f 93       	push	r17
     a04:	2f 93       	push	r18
     a06:	3f 93       	push	r19
     a08:	4f 93       	push	r20
     a0a:	5f 93       	push	r21
     a0c:	6f 93       	push	r22
     a0e:	7f 93       	push	r23
     a10:	8f 93       	push	r24
     a12:	9f 93       	push	r25
     a14:	af 93       	push	r26
     a16:	bf 93       	push	r27
     a18:	cf 93       	push	r28
     a1a:	df 93       	push	r29
     a1c:	ef 93       	push	r30
     a1e:	ff 93       	push	r31
     a20:	a0 91 95 07 	lds	r26, 0x0795	; 0x800795 <pxCurrentTCB>
     a24:	b0 91 96 07 	lds	r27, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     a28:	0d b6       	in	r0, 0x3d	; 61
     a2a:	0d 92       	st	X+, r0
     a2c:	0e b6       	in	r0, 0x3e	; 62
	vTaskSwitchContext();
     a2e:	0d 92       	st	X+, r0
	portRESTORE_CONTEXT();
     a30:	70 d3       	rcall	.+1760   	; 0x1112 <vTaskSwitchContext>
     a32:	a0 91 95 07 	lds	r26, 0x0795	; 0x800795 <pxCurrentTCB>
     a36:	b0 91 96 07 	lds	r27, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     a3a:	cd 91       	ld	r28, X+
     a3c:	cd bf       	out	0x3d, r28	; 61
     a3e:	dd 91       	ld	r29, X+
     a40:	de bf       	out	0x3e, r29	; 62
     a42:	ff 91       	pop	r31
     a44:	ef 91       	pop	r30
     a46:	df 91       	pop	r29
     a48:	cf 91       	pop	r28
     a4a:	bf 91       	pop	r27
     a4c:	af 91       	pop	r26
     a4e:	9f 91       	pop	r25
     a50:	8f 91       	pop	r24
     a52:	7f 91       	pop	r23
     a54:	6f 91       	pop	r22
     a56:	5f 91       	pop	r21
     a58:	4f 91       	pop	r20
     a5a:	3f 91       	pop	r19
     a5c:	2f 91       	pop	r18
     a5e:	1f 91       	pop	r17
     a60:	0f 91       	pop	r16
     a62:	ff 90       	pop	r15
     a64:	ef 90       	pop	r14
     a66:	df 90       	pop	r13
     a68:	cf 90       	pop	r12
     a6a:	bf 90       	pop	r11
     a6c:	af 90       	pop	r10
     a6e:	9f 90       	pop	r9
     a70:	8f 90       	pop	r8
     a72:	7f 90       	pop	r7
     a74:	6f 90       	pop	r6
     a76:	5f 90       	pop	r5
     a78:	4f 90       	pop	r4
     a7a:	3f 90       	pop	r3
     a7c:	2f 90       	pop	r2
     a7e:	1f 90       	pop	r1
     a80:	0f 90       	pop	r0
     a82:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
     a84:	0f 90       	pop	r0
     a86:	08 95       	ret

00000a88 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
     a88:	0f 92       	push	r0
     a8a:	0f b6       	in	r0, 0x3f	; 63
     a8c:	f8 94       	cli
     a8e:	0f 92       	push	r0
     a90:	1f 92       	push	r1
     a92:	11 24       	eor	r1, r1
     a94:	2f 92       	push	r2
     a96:	3f 92       	push	r3
     a98:	4f 92       	push	r4
     a9a:	5f 92       	push	r5
     a9c:	6f 92       	push	r6
     a9e:	7f 92       	push	r7
     aa0:	8f 92       	push	r8
     aa2:	9f 92       	push	r9
     aa4:	af 92       	push	r10
     aa6:	bf 92       	push	r11
     aa8:	cf 92       	push	r12
     aaa:	df 92       	push	r13
     aac:	ef 92       	push	r14
     aae:	ff 92       	push	r15
     ab0:	0f 93       	push	r16
     ab2:	1f 93       	push	r17
     ab4:	2f 93       	push	r18
     ab6:	3f 93       	push	r19
     ab8:	4f 93       	push	r20
     aba:	5f 93       	push	r21
     abc:	6f 93       	push	r22
     abe:	7f 93       	push	r23
     ac0:	8f 93       	push	r24
     ac2:	9f 93       	push	r25
     ac4:	af 93       	push	r26
     ac6:	bf 93       	push	r27
     ac8:	cf 93       	push	r28
     aca:	df 93       	push	r29
     acc:	ef 93       	push	r30
     ace:	ff 93       	push	r31
     ad0:	a0 91 95 07 	lds	r26, 0x0795	; 0x800795 <pxCurrentTCB>
     ad4:	b0 91 96 07 	lds	r27, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     ad8:	0d b6       	in	r0, 0x3d	; 61
     ada:	0d 92       	st	X+, r0
     adc:	0e b6       	in	r0, 0x3e	; 62
	vTaskIncrementTick();
	vTaskSwitchContext();
     ade:	0d 92       	st	X+, r0
     ae0:	85 d1       	rcall	.+778    	; 0xdec <vTaskIncrementTick>
	portRESTORE_CONTEXT();
     ae2:	17 d3       	rcall	.+1582   	; 0x1112 <vTaskSwitchContext>
     ae4:	a0 91 95 07 	lds	r26, 0x0795	; 0x800795 <pxCurrentTCB>
     ae8:	b0 91 96 07 	lds	r27, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     aec:	cd 91       	ld	r28, X+
     aee:	cd bf       	out	0x3d, r28	; 61
     af0:	dd 91       	ld	r29, X+
     af2:	de bf       	out	0x3e, r29	; 62
     af4:	ff 91       	pop	r31
     af6:	ef 91       	pop	r30
     af8:	df 91       	pop	r29
     afa:	cf 91       	pop	r28
     afc:	bf 91       	pop	r27
     afe:	af 91       	pop	r26
     b00:	9f 91       	pop	r25
     b02:	8f 91       	pop	r24
     b04:	7f 91       	pop	r23
     b06:	6f 91       	pop	r22
     b08:	5f 91       	pop	r21
     b0a:	4f 91       	pop	r20
     b0c:	3f 91       	pop	r19
     b0e:	2f 91       	pop	r18
     b10:	1f 91       	pop	r17
     b12:	0f 91       	pop	r16
     b14:	ff 90       	pop	r15
     b16:	ef 90       	pop	r14
     b18:	df 90       	pop	r13
     b1a:	cf 90       	pop	r12
     b1c:	bf 90       	pop	r11
     b1e:	af 90       	pop	r10
     b20:	9f 90       	pop	r9
     b22:	8f 90       	pop	r8
     b24:	7f 90       	pop	r7
     b26:	6f 90       	pop	r6
     b28:	5f 90       	pop	r5
     b2a:	4f 90       	pop	r4
     b2c:	3f 90       	pop	r3
     b2e:	2f 90       	pop	r2
     b30:	1f 90       	pop	r1
     b32:	0f 90       	pop	r0
     b34:	0f be       	out	0x3f, r0	; 63

	asm volatile ( "ret" );
     b36:	0f 90       	pop	r0
     b38:	08 95       	ret

00000b3a <__vector_13>:
     b3a:	a6 df       	rcall	.-180    	; 0xa88 <vPortYieldFromTick>
     b3c:	18 95       	reti

00000b3e <prvAddCurrentTaskToDelayedList>:
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
		{
			portYIELD_WITHIN_API();
		}
	}
     b3e:	cf 93       	push	r28
     b40:	df 93       	push	r29
     b42:	ec 01       	movw	r28, r24
     b44:	e0 91 95 07 	lds	r30, 0x0795	; 0x800795 <pxCurrentTCB>
     b48:	f0 91 96 07 	lds	r31, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     b4c:	93 83       	std	Z+3, r25	; 0x03
     b4e:	82 83       	std	Z+2, r24	; 0x02
     b50:	80 91 45 07 	lds	r24, 0x0745	; 0x800745 <xTickCount>
     b54:	90 91 46 07 	lds	r25, 0x0746	; 0x800746 <xTickCount+0x1>
     b58:	c8 17       	cp	r28, r24
     b5a:	d9 07       	cpc	r29, r25
     b5c:	60 f4       	brcc	.+24     	; 0xb76 <prvAddCurrentTaskToDelayedList+0x38>
     b5e:	60 91 95 07 	lds	r22, 0x0795	; 0x800795 <pxCurrentTCB>
     b62:	70 91 96 07 	lds	r23, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     b66:	80 91 5b 07 	lds	r24, 0x075B	; 0x80075b <pxOverflowDelayedTaskList>
     b6a:	90 91 5c 07 	lds	r25, 0x075C	; 0x80075c <pxOverflowDelayedTaskList+0x1>
     b6e:	6e 5f       	subi	r22, 0xFE	; 254
     b70:	7f 4f       	sbci	r23, 0xFF	; 255
     b72:	09 db       	rcall	.-2542   	; 0x186 <vListInsert>
     b74:	16 c0       	rjmp	.+44     	; 0xba2 <prvAddCurrentTaskToDelayedList+0x64>
     b76:	60 91 95 07 	lds	r22, 0x0795	; 0x800795 <pxCurrentTCB>
     b7a:	70 91 96 07 	lds	r23, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     b7e:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <pxDelayedTaskList>
     b82:	90 91 5e 07 	lds	r25, 0x075E	; 0x80075e <pxDelayedTaskList+0x1>
     b86:	6e 5f       	subi	r22, 0xFE	; 254
     b88:	7f 4f       	sbci	r23, 0xFF	; 255
     b8a:	fd da       	rcall	.-2566   	; 0x186 <vListInsert>
     b8c:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <xNextTaskUnblockTime>
     b90:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <xNextTaskUnblockTime+0x1>
     b94:	c8 17       	cp	r28, r24
     b96:	d9 07       	cpc	r29, r25
     b98:	20 f4       	brcc	.+8      	; 0xba2 <prvAddCurrentTaskToDelayedList+0x64>
     b9a:	d0 93 15 01 	sts	0x0115, r29	; 0x800115 <xNextTaskUnblockTime+0x1>
     b9e:	c0 93 14 01 	sts	0x0114, r28	; 0x800114 <xNextTaskUnblockTime>
     ba2:	df 91       	pop	r29
     ba4:	cf 91       	pop	r28
     ba6:	08 95       	ret

00000ba8 <xTaskGenericCreate>:
     ba8:	4f 92       	push	r4
     baa:	5f 92       	push	r5
     bac:	6f 92       	push	r6
     bae:	7f 92       	push	r7
     bb0:	8f 92       	push	r8
     bb2:	9f 92       	push	r9
     bb4:	af 92       	push	r10
     bb6:	bf 92       	push	r11
     bb8:	cf 92       	push	r12
     bba:	df 92       	push	r13
     bbc:	ef 92       	push	r14
     bbe:	ff 92       	push	r15
     bc0:	0f 93       	push	r16
     bc2:	1f 93       	push	r17
     bc4:	cf 93       	push	r28
     bc6:	df 93       	push	r29
     bc8:	5c 01       	movw	r10, r24
     bca:	4b 01       	movw	r8, r22
     bcc:	3a 01       	movw	r6, r20
     bce:	29 01       	movw	r4, r18
     bd0:	81 e2       	ldi	r24, 0x21	; 33
     bd2:	90 e0       	ldi	r25, 0x00	; 0
     bd4:	7a da       	rcall	.-2828   	; 0xca <pvPortMalloc>
     bd6:	ec 01       	movw	r28, r24
     bd8:	89 2b       	or	r24, r25
     bda:	09 f4       	brne	.+2      	; 0xbde <xTaskGenericCreate+0x36>
     bdc:	c6 c0       	rjmp	.+396    	; 0xd6a <xTaskGenericCreate+0x1c2>
     bde:	c1 14       	cp	r12, r1
     be0:	d1 04       	cpc	r13, r1
     be2:	09 f0       	breq	.+2      	; 0xbe6 <xTaskGenericCreate+0x3e>
     be4:	be c0       	rjmp	.+380    	; 0xd62 <xTaskGenericCreate+0x1ba>
     be6:	c3 01       	movw	r24, r6
     be8:	70 da       	rcall	.-2848   	; 0xca <pvPortMalloc>
     bea:	98 8f       	std	Y+24, r25	; 0x18
     bec:	8f 8b       	std	Y+23, r24	; 0x17
     bee:	00 97       	sbiw	r24, 0x00	; 0
     bf0:	19 f4       	brne	.+6      	; 0xbf8 <xTaskGenericCreate+0x50>
     bf2:	ce 01       	movw	r24, r28
     bf4:	8e da       	rcall	.-2788   	; 0x112 <vPortFree>
     bf6:	b9 c0       	rjmp	.+370    	; 0xd6a <xTaskGenericCreate+0x1c2>
     bf8:	a3 01       	movw	r20, r6
     bfa:	65 ea       	ldi	r22, 0xA5	; 165
     bfc:	70 e0       	ldi	r23, 0x00	; 0
     bfe:	04 d3       	rcall	.+1544   	; 0x1208 <memset>
     c00:	93 01       	movw	r18, r6
     c02:	21 50       	subi	r18, 0x01	; 1
     c04:	31 09       	sbc	r19, r1
     c06:	8f 89       	ldd	r24, Y+23	; 0x17
     c08:	98 8d       	ldd	r25, Y+24	; 0x18
     c0a:	3c 01       	movw	r6, r24
     c0c:	62 0e       	add	r6, r18
     c0e:	73 1e       	adc	r7, r19
     c10:	48 e0       	ldi	r20, 0x08	; 8
     c12:	50 e0       	ldi	r21, 0x00	; 0
     c14:	b4 01       	movw	r22, r8
     c16:	ce 01       	movw	r24, r28
     c18:	49 96       	adiw	r24, 0x19	; 25
     c1a:	fd d2       	rcall	.+1530   	; 0x1216 <strncpy>
     c1c:	18 a2       	std	Y+32, r1	; 0x20
     c1e:	10 2f       	mov	r17, r16
     c20:	04 30       	cpi	r16, 0x04	; 4
     c22:	08 f0       	brcs	.+2      	; 0xc26 <xTaskGenericCreate+0x7e>
     c24:	13 e0       	ldi	r17, 0x03	; 3
     c26:	1e 8b       	std	Y+22, r17	; 0x16
     c28:	6e 01       	movw	r12, r28
     c2a:	82 e0       	ldi	r24, 0x02	; 2
     c2c:	c8 0e       	add	r12, r24
     c2e:	d1 1c       	adc	r13, r1
     c30:	c6 01       	movw	r24, r12
     c32:	7e da       	rcall	.-2820   	; 0x130 <vListInitialiseItem>
     c34:	ce 01       	movw	r24, r28
     c36:	0c 96       	adiw	r24, 0x0c	; 12
     c38:	7b da       	rcall	.-2826   	; 0x130 <vListInitialiseItem>
     c3a:	d9 87       	std	Y+9, r29	; 0x09
     c3c:	c8 87       	std	Y+8, r28	; 0x08
     c3e:	84 e0       	ldi	r24, 0x04	; 4
     c40:	90 e0       	ldi	r25, 0x00	; 0
     c42:	81 1b       	sub	r24, r17
     c44:	91 09       	sbc	r25, r1
     c46:	9d 87       	std	Y+13, r25	; 0x0d
     c48:	8c 87       	std	Y+12, r24	; 0x0c
     c4a:	db 8b       	std	Y+19, r29	; 0x13
     c4c:	ca 8b       	std	Y+18, r28	; 0x12
     c4e:	a2 01       	movw	r20, r4
     c50:	b5 01       	movw	r22, r10
     c52:	c3 01       	movw	r24, r6
     c54:	1b de       	rcall	.-970    	; 0x88c <pxPortInitialiseStack>
     c56:	99 83       	std	Y+1, r25	; 0x01
     c58:	88 83       	st	Y, r24
     c5a:	e1 14       	cp	r14, r1
     c5c:	f1 04       	cpc	r15, r1
     c5e:	19 f0       	breq	.+6      	; 0xc66 <xTaskGenericCreate+0xbe>
     c60:	f7 01       	movw	r30, r14
     c62:	d1 83       	std	Z+1, r29	; 0x01
     c64:	c0 83       	st	Z, r28
     c66:	0f b6       	in	r0, 0x3f	; 63
     c68:	f8 94       	cli
     c6a:	0f 92       	push	r0
     c6c:	80 91 47 07 	lds	r24, 0x0747	; 0x800747 <uxCurrentNumberOfTasks>
     c70:	8f 5f       	subi	r24, 0xFF	; 255
     c72:	80 93 47 07 	sts	0x0747, r24	; 0x800747 <uxCurrentNumberOfTasks>
     c76:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <pxCurrentTCB>
     c7a:	90 91 96 07 	lds	r25, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     c7e:	89 2b       	or	r24, r25
     c80:	69 f5       	brne	.+90     	; 0xcdc <xTaskGenericCreate+0x134>
     c82:	d0 93 96 07 	sts	0x0796, r29	; 0x800796 <pxCurrentTCB+0x1>
     c86:	c0 93 95 07 	sts	0x0795, r28	; 0x800795 <pxCurrentTCB>
     c8a:	80 91 47 07 	lds	r24, 0x0747	; 0x800747 <uxCurrentNumberOfTasks>
     c8e:	81 30       	cpi	r24, 0x01	; 1
     c90:	a1 f5       	brne	.+104    	; 0xcfa <xTaskGenericCreate+0x152>
     c92:	81 e7       	ldi	r24, 0x71	; 113
     c94:	97 e0       	ldi	r25, 0x07	; 7
     c96:	3e da       	rcall	.-2948   	; 0x114 <vListInitialise>
     c98:	8a e7       	ldi	r24, 0x7A	; 122
     c9a:	97 e0       	ldi	r25, 0x07	; 7
     c9c:	3b da       	rcall	.-2954   	; 0x114 <vListInitialise>
     c9e:	83 e8       	ldi	r24, 0x83	; 131
     ca0:	97 e0       	ldi	r25, 0x07	; 7
     ca2:	38 da       	rcall	.-2960   	; 0x114 <vListInitialise>
     ca4:	8c e8       	ldi	r24, 0x8C	; 140
     ca6:	97 e0       	ldi	r25, 0x07	; 7
     ca8:	35 da       	rcall	.-2966   	; 0x114 <vListInitialise>
     caa:	88 e6       	ldi	r24, 0x68	; 104
     cac:	97 e0       	ldi	r25, 0x07	; 7
     cae:	32 da       	rcall	.-2972   	; 0x114 <vListInitialise>
     cb0:	8f e5       	ldi	r24, 0x5F	; 95
     cb2:	97 e0       	ldi	r25, 0x07	; 7
     cb4:	2f da       	rcall	.-2978   	; 0x114 <vListInitialise>
     cb6:	82 e5       	ldi	r24, 0x52	; 82
     cb8:	97 e0       	ldi	r25, 0x07	; 7
     cba:	2c da       	rcall	.-2984   	; 0x114 <vListInitialise>
     cbc:	89 e4       	ldi	r24, 0x49	; 73
     cbe:	97 e0       	ldi	r25, 0x07	; 7
     cc0:	29 da       	rcall	.-2990   	; 0x114 <vListInitialise>
     cc2:	88 e6       	ldi	r24, 0x68	; 104
     cc4:	97 e0       	ldi	r25, 0x07	; 7
     cc6:	90 93 5e 07 	sts	0x075E, r25	; 0x80075e <pxDelayedTaskList+0x1>
     cca:	80 93 5d 07 	sts	0x075D, r24	; 0x80075d <pxDelayedTaskList>
     cce:	8f e5       	ldi	r24, 0x5F	; 95
     cd0:	97 e0       	ldi	r25, 0x07	; 7
     cd2:	90 93 5c 07 	sts	0x075C, r25	; 0x80075c <pxOverflowDelayedTaskList+0x1>
     cd6:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <pxOverflowDelayedTaskList>
     cda:	0f c0       	rjmp	.+30     	; 0xcfa <xTaskGenericCreate+0x152>
     cdc:	80 91 42 07 	lds	r24, 0x0742	; 0x800742 <xSchedulerRunning>
     ce0:	81 11       	cpse	r24, r1
     ce2:	0b c0       	rjmp	.+22     	; 0xcfa <xTaskGenericCreate+0x152>
     ce4:	e0 91 95 07 	lds	r30, 0x0795	; 0x800795 <pxCurrentTCB>
     ce8:	f0 91 96 07 	lds	r31, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     cec:	86 89       	ldd	r24, Z+22	; 0x16
     cee:	08 17       	cp	r16, r24
     cf0:	20 f0       	brcs	.+8      	; 0xcfa <xTaskGenericCreate+0x152>
     cf2:	d0 93 96 07 	sts	0x0796, r29	; 0x800796 <pxCurrentTCB+0x1>
     cf6:	c0 93 95 07 	sts	0x0795, r28	; 0x800795 <pxCurrentTCB>
     cfa:	8e 89       	ldd	r24, Y+22	; 0x16
     cfc:	90 91 44 07 	lds	r25, 0x0744	; 0x800744 <uxTopUsedPriority>
     d00:	98 17       	cp	r25, r24
     d02:	10 f4       	brcc	.+4      	; 0xd08 <xTaskGenericCreate+0x160>
     d04:	80 93 44 07 	sts	0x0744, r24	; 0x800744 <uxTopUsedPriority>
     d08:	90 91 3d 07 	lds	r25, 0x073D	; 0x80073d <uxTaskNumber>
     d0c:	9f 5f       	subi	r25, 0xFF	; 255
     d0e:	90 93 3d 07 	sts	0x073D, r25	; 0x80073d <uxTaskNumber>
     d12:	90 91 43 07 	lds	r25, 0x0743	; 0x800743 <uxTopReadyPriority>
     d16:	98 17       	cp	r25, r24
     d18:	10 f4       	brcc	.+4      	; 0xd1e <xTaskGenericCreate+0x176>
     d1a:	80 93 43 07 	sts	0x0743, r24	; 0x800743 <uxTopReadyPriority>
     d1e:	90 e0       	ldi	r25, 0x00	; 0
     d20:	9c 01       	movw	r18, r24
     d22:	22 0f       	add	r18, r18
     d24:	33 1f       	adc	r19, r19
     d26:	22 0f       	add	r18, r18
     d28:	33 1f       	adc	r19, r19
     d2a:	22 0f       	add	r18, r18
     d2c:	33 1f       	adc	r19, r19
     d2e:	82 0f       	add	r24, r18
     d30:	93 1f       	adc	r25, r19
     d32:	b6 01       	movw	r22, r12
     d34:	8f 58       	subi	r24, 0x8F	; 143
     d36:	98 4f       	sbci	r25, 0xF8	; 248
     d38:	ff d9       	rcall	.-3074   	; 0x138 <vListInsertEnd>
     d3a:	0f 90       	pop	r0
     d3c:	0f be       	out	0x3f, r0	; 63
     d3e:	80 91 42 07 	lds	r24, 0x0742	; 0x800742 <xSchedulerRunning>
     d42:	88 23       	and	r24, r24
     d44:	51 f0       	breq	.+20     	; 0xd5a <xTaskGenericCreate+0x1b2>
     d46:	e0 91 95 07 	lds	r30, 0x0795	; 0x800795 <pxCurrentTCB>
     d4a:	f0 91 96 07 	lds	r31, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     d4e:	86 89       	ldd	r24, Z+22	; 0x16
     d50:	80 17       	cp	r24, r16
     d52:	28 f4       	brcc	.+10     	; 0xd5e <xTaskGenericCreate+0x1b6>
     d54:	41 de       	rcall	.-894    	; 0x9d8 <vPortYield>
     d56:	81 e0       	ldi	r24, 0x01	; 1
     d58:	09 c0       	rjmp	.+18     	; 0xd6c <xTaskGenericCreate+0x1c4>
     d5a:	81 e0       	ldi	r24, 0x01	; 1
     d5c:	07 c0       	rjmp	.+14     	; 0xd6c <xTaskGenericCreate+0x1c4>
     d5e:	81 e0       	ldi	r24, 0x01	; 1
     d60:	05 c0       	rjmp	.+10     	; 0xd6c <xTaskGenericCreate+0x1c4>
     d62:	d8 8e       	std	Y+24, r13	; 0x18
     d64:	cf 8a       	std	Y+23, r12	; 0x17
     d66:	c6 01       	movw	r24, r12
     d68:	47 cf       	rjmp	.-370    	; 0xbf8 <xTaskGenericCreate+0x50>
     d6a:	8f ef       	ldi	r24, 0xFF	; 255
     d6c:	df 91       	pop	r29
     d6e:	cf 91       	pop	r28
     d70:	1f 91       	pop	r17
     d72:	0f 91       	pop	r16
     d74:	ff 90       	pop	r15
     d76:	ef 90       	pop	r14
     d78:	df 90       	pop	r13
     d7a:	cf 90       	pop	r12
     d7c:	bf 90       	pop	r11
     d7e:	af 90       	pop	r10
     d80:	9f 90       	pop	r9
     d82:	8f 90       	pop	r8
     d84:	7f 90       	pop	r7
     d86:	6f 90       	pop	r6
     d88:	5f 90       	pop	r5
     d8a:	4f 90       	pop	r4
     d8c:	08 95       	ret

00000d8e <vTaskStartScheduler>:
     d8e:	af 92       	push	r10
     d90:	bf 92       	push	r11
     d92:	cf 92       	push	r12
     d94:	df 92       	push	r13
     d96:	ef 92       	push	r14
     d98:	ff 92       	push	r15
     d9a:	0f 93       	push	r16
     d9c:	a1 2c       	mov	r10, r1
     d9e:	b1 2c       	mov	r11, r1
     da0:	c1 2c       	mov	r12, r1
     da2:	d1 2c       	mov	r13, r1
     da4:	e1 2c       	mov	r14, r1
     da6:	f1 2c       	mov	r15, r1
     da8:	00 e0       	ldi	r16, 0x00	; 0
     daa:	20 e0       	ldi	r18, 0x00	; 0
     dac:	30 e0       	ldi	r19, 0x00	; 0
     dae:	45 e5       	ldi	r20, 0x55	; 85
     db0:	50 e0       	ldi	r21, 0x00	; 0
     db2:	69 e4       	ldi	r22, 0x49	; 73
     db4:	71 e0       	ldi	r23, 0x01	; 1
     db6:	83 e5       	ldi	r24, 0x53	; 83
     db8:	98 e0       	ldi	r25, 0x08	; 8
     dba:	f6 de       	rcall	.-532    	; 0xba8 <xTaskGenericCreate>
     dbc:	81 30       	cpi	r24, 0x01	; 1
     dbe:	41 f4       	brne	.+16     	; 0xdd0 <vTaskStartScheduler+0x42>
     dc0:	f8 94       	cli
     dc2:	80 93 42 07 	sts	0x0742, r24	; 0x800742 <xSchedulerRunning>
     dc6:	10 92 46 07 	sts	0x0746, r1	; 0x800746 <xTickCount+0x1>
     dca:	10 92 45 07 	sts	0x0745, r1	; 0x800745 <xTickCount>
     dce:	ca dd       	rcall	.-1132   	; 0x964 <xPortStartScheduler>
     dd0:	0f 91       	pop	r16
     dd2:	ff 90       	pop	r15
     dd4:	ef 90       	pop	r14
     dd6:	df 90       	pop	r13
     dd8:	cf 90       	pop	r12
     dda:	bf 90       	pop	r11
     ddc:	af 90       	pop	r10
     dde:	08 95       	ret

00000de0 <vTaskSuspendAll>:
     de0:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <uxSchedulerSuspended>
     de4:	8f 5f       	subi	r24, 0xFF	; 255
     de6:	80 93 41 07 	sts	0x0741, r24	; 0x800741 <uxSchedulerSuspended>
     dea:	08 95       	ret

00000dec <vTaskIncrementTick>:
     dec:	0f 93       	push	r16
     dee:	1f 93       	push	r17
     df0:	cf 93       	push	r28
     df2:	df 93       	push	r29
     df4:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <uxSchedulerSuspended>
     df8:	81 11       	cpse	r24, r1
     dfa:	af c0       	rjmp	.+350    	; 0xf5a <vTaskIncrementTick+0x16e>
     dfc:	80 91 45 07 	lds	r24, 0x0745	; 0x800745 <xTickCount>
     e00:	90 91 46 07 	lds	r25, 0x0746	; 0x800746 <xTickCount+0x1>
     e04:	01 96       	adiw	r24, 0x01	; 1
     e06:	90 93 46 07 	sts	0x0746, r25	; 0x800746 <xTickCount+0x1>
     e0a:	80 93 45 07 	sts	0x0745, r24	; 0x800745 <xTickCount>
     e0e:	80 91 45 07 	lds	r24, 0x0745	; 0x800745 <xTickCount>
     e12:	90 91 46 07 	lds	r25, 0x0746	; 0x800746 <xTickCount+0x1>
     e16:	89 2b       	or	r24, r25
     e18:	99 f5       	brne	.+102    	; 0xe80 <vTaskIncrementTick+0x94>
     e1a:	80 91 5d 07 	lds	r24, 0x075D	; 0x80075d <pxDelayedTaskList>
     e1e:	90 91 5e 07 	lds	r25, 0x075E	; 0x80075e <pxDelayedTaskList+0x1>
     e22:	20 91 5b 07 	lds	r18, 0x075B	; 0x80075b <pxOverflowDelayedTaskList>
     e26:	30 91 5c 07 	lds	r19, 0x075C	; 0x80075c <pxOverflowDelayedTaskList+0x1>
     e2a:	30 93 5e 07 	sts	0x075E, r19	; 0x80075e <pxDelayedTaskList+0x1>
     e2e:	20 93 5d 07 	sts	0x075D, r18	; 0x80075d <pxDelayedTaskList>
     e32:	90 93 5c 07 	sts	0x075C, r25	; 0x80075c <pxOverflowDelayedTaskList+0x1>
     e36:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <pxOverflowDelayedTaskList>
     e3a:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <xNumOfOverflows>
     e3e:	8f 5f       	subi	r24, 0xFF	; 255
     e40:	80 93 3e 07 	sts	0x073E, r24	; 0x80073e <xNumOfOverflows>
     e44:	e0 91 5d 07 	lds	r30, 0x075D	; 0x80075d <pxDelayedTaskList>
     e48:	f0 91 5e 07 	lds	r31, 0x075E	; 0x80075e <pxDelayedTaskList+0x1>
     e4c:	80 81       	ld	r24, Z
     e4e:	81 11       	cpse	r24, r1
     e50:	07 c0       	rjmp	.+14     	; 0xe60 <vTaskIncrementTick+0x74>
     e52:	8f ef       	ldi	r24, 0xFF	; 255
     e54:	9f ef       	ldi	r25, 0xFF	; 255
     e56:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <xNextTaskUnblockTime+0x1>
     e5a:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <xNextTaskUnblockTime>
     e5e:	10 c0       	rjmp	.+32     	; 0xe80 <vTaskIncrementTick+0x94>
     e60:	e0 91 5d 07 	lds	r30, 0x075D	; 0x80075d <pxDelayedTaskList>
     e64:	f0 91 5e 07 	lds	r31, 0x075E	; 0x80075e <pxDelayedTaskList+0x1>
     e68:	05 80       	ldd	r0, Z+5	; 0x05
     e6a:	f6 81       	ldd	r31, Z+6	; 0x06
     e6c:	e0 2d       	mov	r30, r0
     e6e:	06 80       	ldd	r0, Z+6	; 0x06
     e70:	f7 81       	ldd	r31, Z+7	; 0x07
     e72:	e0 2d       	mov	r30, r0
     e74:	82 81       	ldd	r24, Z+2	; 0x02
     e76:	93 81       	ldd	r25, Z+3	; 0x03
     e78:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <xNextTaskUnblockTime+0x1>
     e7c:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <xNextTaskUnblockTime>
     e80:	20 91 45 07 	lds	r18, 0x0745	; 0x800745 <xTickCount>
     e84:	30 91 46 07 	lds	r19, 0x0746	; 0x800746 <xTickCount+0x1>
     e88:	80 91 14 01 	lds	r24, 0x0114	; 0x800114 <xNextTaskUnblockTime>
     e8c:	90 91 15 01 	lds	r25, 0x0115	; 0x800115 <xNextTaskUnblockTime+0x1>
     e90:	28 17       	cp	r18, r24
     e92:	39 07       	cpc	r19, r25
     e94:	08 f4       	brcc	.+2      	; 0xe98 <vTaskIncrementTick+0xac>
     e96:	66 c0       	rjmp	.+204    	; 0xf64 <vTaskIncrementTick+0x178>
     e98:	e0 91 5d 07 	lds	r30, 0x075D	; 0x80075d <pxDelayedTaskList>
     e9c:	f0 91 5e 07 	lds	r31, 0x075E	; 0x80075e <pxDelayedTaskList+0x1>
     ea0:	80 81       	ld	r24, Z
     ea2:	88 23       	and	r24, r24
     ea4:	99 f0       	breq	.+38     	; 0xecc <vTaskIncrementTick+0xe0>
     ea6:	e0 91 5d 07 	lds	r30, 0x075D	; 0x80075d <pxDelayedTaskList>
     eaa:	f0 91 5e 07 	lds	r31, 0x075E	; 0x80075e <pxDelayedTaskList+0x1>
     eae:	05 80       	ldd	r0, Z+5	; 0x05
     eb0:	f6 81       	ldd	r31, Z+6	; 0x06
     eb2:	e0 2d       	mov	r30, r0
     eb4:	c6 81       	ldd	r28, Z+6	; 0x06
     eb6:	d7 81       	ldd	r29, Z+7	; 0x07
     eb8:	8a 81       	ldd	r24, Y+2	; 0x02
     eba:	9b 81       	ldd	r25, Y+3	; 0x03
     ebc:	20 91 45 07 	lds	r18, 0x0745	; 0x800745 <xTickCount>
     ec0:	30 91 46 07 	lds	r19, 0x0746	; 0x800746 <xTickCount+0x1>
     ec4:	28 17       	cp	r18, r24
     ec6:	39 07       	cpc	r19, r25
     ec8:	f8 f4       	brcc	.+62     	; 0xf08 <vTaskIncrementTick+0x11c>
     eca:	19 c0       	rjmp	.+50     	; 0xefe <vTaskIncrementTick+0x112>
     ecc:	8f ef       	ldi	r24, 0xFF	; 255
     ece:	9f ef       	ldi	r25, 0xFF	; 255
     ed0:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <xNextTaskUnblockTime+0x1>
     ed4:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <xNextTaskUnblockTime>
     ed8:	45 c0       	rjmp	.+138    	; 0xf64 <vTaskIncrementTick+0x178>
     eda:	e0 91 5d 07 	lds	r30, 0x075D	; 0x80075d <pxDelayedTaskList>
     ede:	f0 91 5e 07 	lds	r31, 0x075E	; 0x80075e <pxDelayedTaskList+0x1>
     ee2:	05 80       	ldd	r0, Z+5	; 0x05
     ee4:	f6 81       	ldd	r31, Z+6	; 0x06
     ee6:	e0 2d       	mov	r30, r0
     ee8:	c6 81       	ldd	r28, Z+6	; 0x06
     eea:	d7 81       	ldd	r29, Z+7	; 0x07
     eec:	8a 81       	ldd	r24, Y+2	; 0x02
     eee:	9b 81       	ldd	r25, Y+3	; 0x03
     ef0:	20 91 45 07 	lds	r18, 0x0745	; 0x800745 <xTickCount>
     ef4:	30 91 46 07 	lds	r19, 0x0746	; 0x800746 <xTickCount+0x1>
     ef8:	28 17       	cp	r18, r24
     efa:	39 07       	cpc	r19, r25
     efc:	28 f4       	brcc	.+10     	; 0xf08 <vTaskIncrementTick+0x11c>
     efe:	90 93 15 01 	sts	0x0115, r25	; 0x800115 <xNextTaskUnblockTime+0x1>
     f02:	80 93 14 01 	sts	0x0114, r24	; 0x800114 <xNextTaskUnblockTime>
     f06:	2e c0       	rjmp	.+92     	; 0xf64 <vTaskIncrementTick+0x178>
     f08:	8e 01       	movw	r16, r28
     f0a:	0e 5f       	subi	r16, 0xFE	; 254
     f0c:	1f 4f       	sbci	r17, 0xFF	; 255
     f0e:	c8 01       	movw	r24, r16
     f10:	75 d9       	rcall	.-3350   	; 0x1fc <vListRemove>
     f12:	8c 89       	ldd	r24, Y+20	; 0x14
     f14:	9d 89       	ldd	r25, Y+21	; 0x15
     f16:	89 2b       	or	r24, r25
     f18:	19 f0       	breq	.+6      	; 0xf20 <vTaskIncrementTick+0x134>
     f1a:	ce 01       	movw	r24, r28
     f1c:	0c 96       	adiw	r24, 0x0c	; 12
     f1e:	6e d9       	rcall	.-3364   	; 0x1fc <vListRemove>
     f20:	8e 89       	ldd	r24, Y+22	; 0x16
     f22:	90 91 43 07 	lds	r25, 0x0743	; 0x800743 <uxTopReadyPriority>
     f26:	98 17       	cp	r25, r24
     f28:	10 f4       	brcc	.+4      	; 0xf2e <vTaskIncrementTick+0x142>
     f2a:	80 93 43 07 	sts	0x0743, r24	; 0x800743 <uxTopReadyPriority>
     f2e:	90 e0       	ldi	r25, 0x00	; 0
     f30:	9c 01       	movw	r18, r24
     f32:	22 0f       	add	r18, r18
     f34:	33 1f       	adc	r19, r19
     f36:	22 0f       	add	r18, r18
     f38:	33 1f       	adc	r19, r19
     f3a:	22 0f       	add	r18, r18
     f3c:	33 1f       	adc	r19, r19
     f3e:	82 0f       	add	r24, r18
     f40:	93 1f       	adc	r25, r19
     f42:	b8 01       	movw	r22, r16
     f44:	8f 58       	subi	r24, 0x8F	; 143
     f46:	98 4f       	sbci	r25, 0xF8	; 248
     f48:	f7 d8       	rcall	.-3602   	; 0x138 <vListInsertEnd>
     f4a:	e0 91 5d 07 	lds	r30, 0x075D	; 0x80075d <pxDelayedTaskList>
     f4e:	f0 91 5e 07 	lds	r31, 0x075E	; 0x80075e <pxDelayedTaskList+0x1>
     f52:	80 81       	ld	r24, Z
     f54:	81 11       	cpse	r24, r1
     f56:	c1 cf       	rjmp	.-126    	; 0xeda <vTaskIncrementTick+0xee>
     f58:	b9 cf       	rjmp	.-142    	; 0xecc <vTaskIncrementTick+0xe0>
     f5a:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <uxMissedTicks>
     f5e:	8f 5f       	subi	r24, 0xFF	; 255
     f60:	80 93 40 07 	sts	0x0740, r24	; 0x800740 <uxMissedTicks>
     f64:	df 91       	pop	r29
     f66:	cf 91       	pop	r28
     f68:	1f 91       	pop	r17
     f6a:	0f 91       	pop	r16
     f6c:	08 95       	ret

00000f6e <xTaskResumeAll>:
     f6e:	cf 92       	push	r12
     f70:	df 92       	push	r13
     f72:	ef 92       	push	r14
     f74:	ff 92       	push	r15
     f76:	0f 93       	push	r16
     f78:	1f 93       	push	r17
     f7a:	cf 93       	push	r28
     f7c:	df 93       	push	r29
     f7e:	0f b6       	in	r0, 0x3f	; 63
     f80:	f8 94       	cli
     f82:	0f 92       	push	r0
     f84:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <uxSchedulerSuspended>
     f88:	81 50       	subi	r24, 0x01	; 1
     f8a:	80 93 41 07 	sts	0x0741, r24	; 0x800741 <uxSchedulerSuspended>
     f8e:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <uxSchedulerSuspended>
     f92:	81 11       	cpse	r24, r1
     f94:	5f c0       	rjmp	.+190    	; 0x1054 <xTaskResumeAll+0xe6>
     f96:	80 91 47 07 	lds	r24, 0x0747	; 0x800747 <uxCurrentNumberOfTasks>
     f9a:	81 11       	cpse	r24, r1
     f9c:	2f c0       	rjmp	.+94     	; 0xffc <xTaskResumeAll+0x8e>
     f9e:	5d c0       	rjmp	.+186    	; 0x105a <xTaskResumeAll+0xec>
     fa0:	d7 01       	movw	r26, r14
     fa2:	15 96       	adiw	r26, 0x05	; 5
     fa4:	ed 91       	ld	r30, X+
     fa6:	fc 91       	ld	r31, X
     fa8:	16 97       	sbiw	r26, 0x06	; 6
     faa:	c6 81       	ldd	r28, Z+6	; 0x06
     fac:	d7 81       	ldd	r29, Z+7	; 0x07
     fae:	ce 01       	movw	r24, r28
     fb0:	0c 96       	adiw	r24, 0x0c	; 12
     fb2:	24 d9       	rcall	.-3512   	; 0x1fc <vListRemove>
     fb4:	8e 01       	movw	r16, r28
     fb6:	0e 5f       	subi	r16, 0xFE	; 254
     fb8:	1f 4f       	sbci	r17, 0xFF	; 255
     fba:	c8 01       	movw	r24, r16
     fbc:	1f d9       	rcall	.-3522   	; 0x1fc <vListRemove>
     fbe:	8e 89       	ldd	r24, Y+22	; 0x16
     fc0:	90 91 43 07 	lds	r25, 0x0743	; 0x800743 <uxTopReadyPriority>
     fc4:	98 17       	cp	r25, r24
     fc6:	10 f4       	brcc	.+4      	; 0xfcc <xTaskResumeAll+0x5e>
     fc8:	80 93 43 07 	sts	0x0743, r24	; 0x800743 <uxTopReadyPriority>
     fcc:	90 e0       	ldi	r25, 0x00	; 0
     fce:	9c 01       	movw	r18, r24
     fd0:	22 0f       	add	r18, r18
     fd2:	33 1f       	adc	r19, r19
     fd4:	22 0f       	add	r18, r18
     fd6:	33 1f       	adc	r19, r19
     fd8:	22 0f       	add	r18, r18
     fda:	33 1f       	adc	r19, r19
     fdc:	82 0f       	add	r24, r18
     fde:	93 1f       	adc	r25, r19
     fe0:	b8 01       	movw	r22, r16
     fe2:	8f 58       	subi	r24, 0x8F	; 143
     fe4:	98 4f       	sbci	r25, 0xF8	; 248
     fe6:	a8 d8       	rcall	.-3760   	; 0x138 <vListInsertEnd>
     fe8:	e0 91 95 07 	lds	r30, 0x0795	; 0x800795 <pxCurrentTCB>
     fec:	f0 91 96 07 	lds	r31, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
     ff0:	9e 89       	ldd	r25, Y+22	; 0x16
     ff2:	86 89       	ldd	r24, Z+22	; 0x16
     ff4:	98 17       	cp	r25, r24
     ff6:	58 f0       	brcs	.+22     	; 0x100e <xTaskResumeAll+0xa0>
     ff8:	dc 2c       	mov	r13, r12
     ffa:	09 c0       	rjmp	.+18     	; 0x100e <xTaskResumeAll+0xa0>
     ffc:	d1 2c       	mov	r13, r1
     ffe:	0f 2e       	mov	r0, r31
    1000:	f2 e5       	ldi	r31, 0x52	; 82
    1002:	ef 2e       	mov	r14, r31
    1004:	f7 e0       	ldi	r31, 0x07	; 7
    1006:	ff 2e       	mov	r15, r31
    1008:	f0 2d       	mov	r31, r0
    100a:	cc 24       	eor	r12, r12
    100c:	c3 94       	inc	r12
    100e:	f7 01       	movw	r30, r14
    1010:	80 81       	ld	r24, Z
    1012:	81 11       	cpse	r24, r1
    1014:	c5 cf       	rjmp	.-118    	; 0xfa0 <xTaskResumeAll+0x32>
    1016:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <uxMissedTicks>
    101a:	88 23       	and	r24, r24
    101c:	79 f0       	breq	.+30     	; 0x103c <xTaskResumeAll+0xce>
    101e:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <uxMissedTicks>
    1022:	88 23       	and	r24, r24
    1024:	91 f0       	breq	.+36     	; 0x104a <xTaskResumeAll+0xdc>
    1026:	e2 de       	rcall	.-572    	; 0xdec <vTaskIncrementTick>
    1028:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <uxMissedTicks>
    102c:	81 50       	subi	r24, 0x01	; 1
    102e:	80 93 40 07 	sts	0x0740, r24	; 0x800740 <uxMissedTicks>
    1032:	80 91 40 07 	lds	r24, 0x0740	; 0x800740 <uxMissedTicks>
    1036:	81 11       	cpse	r24, r1
    1038:	f6 cf       	rjmp	.-20     	; 0x1026 <xTaskResumeAll+0xb8>
    103a:	07 c0       	rjmp	.+14     	; 0x104a <xTaskResumeAll+0xdc>
    103c:	f1 e0       	ldi	r31, 0x01	; 1
    103e:	df 16       	cp	r13, r31
    1040:	21 f0       	breq	.+8      	; 0x104a <xTaskResumeAll+0xdc>
    1042:	80 91 3f 07 	lds	r24, 0x073F	; 0x80073f <xMissedYield>
    1046:	81 30       	cpi	r24, 0x01	; 1
    1048:	39 f4       	brne	.+14     	; 0x1058 <xTaskResumeAll+0xea>
    104a:	10 92 3f 07 	sts	0x073F, r1	; 0x80073f <xMissedYield>
    104e:	c4 dc       	rcall	.-1656   	; 0x9d8 <vPortYield>
    1050:	81 e0       	ldi	r24, 0x01	; 1
    1052:	03 c0       	rjmp	.+6      	; 0x105a <xTaskResumeAll+0xec>
    1054:	80 e0       	ldi	r24, 0x00	; 0
    1056:	01 c0       	rjmp	.+2      	; 0x105a <xTaskResumeAll+0xec>
    1058:	80 e0       	ldi	r24, 0x00	; 0
    105a:	0f 90       	pop	r0
    105c:	0f be       	out	0x3f, r0	; 63
    105e:	df 91       	pop	r29
    1060:	cf 91       	pop	r28
    1062:	1f 91       	pop	r17
    1064:	0f 91       	pop	r16
    1066:	ff 90       	pop	r15
    1068:	ef 90       	pop	r14
    106a:	df 90       	pop	r13
    106c:	cf 90       	pop	r12
    106e:	08 95       	ret

00001070 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    1070:	cf 93       	push	r28
    1072:	df 93       	push	r29
    1074:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    1076:	89 2b       	or	r24, r25
		{
			vTaskSuspendAll();
    1078:	91 f0       	breq	.+36     	; 0x109e <vTaskDelay+0x2e>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    107a:	b2 de       	rcall	.-668    	; 0xde0 <vTaskSuspendAll>
    107c:	80 91 45 07 	lds	r24, 0x0745	; 0x800745 <xTickCount>
    1080:	90 91 46 07 	lds	r25, 0x0746	; 0x800746 <xTickCount+0x1>
    1084:	c8 0f       	add	r28, r24

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    1086:	d9 1f       	adc	r29, r25
    1088:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <pxCurrentTCB>
    108c:	90 91 96 07 	lds	r25, 0x0796	; 0x800796 <pxCurrentTCB+0x1>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
			}
			xAlreadyYielded = xTaskResumeAll();
    1090:	02 96       	adiw	r24, 0x02	; 2
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    1092:	b4 d8       	rcall	.-3736   	; 0x1fc <vListRemove>
    1094:	ce 01       	movw	r24, r28
		{
			portYIELD_WITHIN_API();
    1096:	53 dd       	rcall	.-1370   	; 0xb3e <prvAddCurrentTaskToDelayedList>
    1098:	6a df       	rcall	.-300    	; 0xf6e <xTaskResumeAll>
		}
	}
    109a:	81 11       	cpse	r24, r1
    109c:	01 c0       	rjmp	.+2      	; 0x10a0 <vTaskDelay+0x30>
    109e:	9c dc       	rcall	.-1736   	; 0x9d8 <vPortYield>
    10a0:	df 91       	pop	r29
    10a2:	cf 91       	pop	r28
    10a4:	08 95       	ret

000010a6 <prvIdleTask>:
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    10a6:	0f 2e       	mov	r0, r31
    10a8:	f9 e4       	ldi	r31, 0x49	; 73
    10aa:	ef 2e       	mov	r14, r31
    10ac:	f7 e0       	ldi	r31, 0x07	; 7
    10ae:	ff 2e       	mov	r15, r31
    10b0:	f0 2d       	mov	r31, r0

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    10b2:	c1 e7       	ldi	r28, 0x71	; 113
    10b4:	d7 e0       	ldi	r29, 0x07	; 7
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		if( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
    10b6:	80 91 48 07 	lds	r24, 0x0748	; 0x800748 <uxTasksDeleted>
    10ba:	88 23       	and	r24, r24
		{
			vTaskSuspendAll();
    10bc:	29 f1       	breq	.+74     	; 0x1108 <prvIdleTask+0x62>
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
    10be:	90 de       	rcall	.-736    	; 0xde0 <vTaskSuspendAll>
			xTaskResumeAll();
    10c0:	d7 01       	movw	r26, r14
    10c2:	1c 91       	ld	r17, X

			if( xListIsEmpty == pdFALSE )
    10c4:	54 df       	rcall	.-344    	; 0xf6e <xTaskResumeAll>
    10c6:	11 23       	and	r17, r17
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
    10c8:	f9 f0       	breq	.+62     	; 0x1108 <prvIdleTask+0x62>
    10ca:	0f b6       	in	r0, 0x3f	; 63
    10cc:	f8 94       	cli
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
    10ce:	0f 92       	push	r0
    10d0:	d7 01       	movw	r26, r14
    10d2:	15 96       	adiw	r26, 0x05	; 5
    10d4:	ed 91       	ld	r30, X+
    10d6:	fc 91       	ld	r31, X
    10d8:	16 97       	sbiw	r26, 0x06	; 6
					vListRemove( &( pxTCB->xGenericListItem ) );
    10da:	06 81       	ldd	r16, Z+6	; 0x06
    10dc:	17 81       	ldd	r17, Z+7	; 0x07
    10de:	c8 01       	movw	r24, r16
					--uxCurrentNumberOfTasks;
    10e0:	02 96       	adiw	r24, 0x02	; 2
    10e2:	8c d8       	rcall	.-3816   	; 0x1fc <vListRemove>
    10e4:	80 91 47 07 	lds	r24, 0x0747	; 0x800747 <uxCurrentNumberOfTasks>
    10e8:	81 50       	subi	r24, 0x01	; 1
					--uxTasksDeleted;
    10ea:	80 93 47 07 	sts	0x0747, r24	; 0x800747 <uxCurrentNumberOfTasks>
    10ee:	80 91 48 07 	lds	r24, 0x0748	; 0x800748 <uxTasksDeleted>
    10f2:	81 50       	subi	r24, 0x01	; 1
				}
				taskEXIT_CRITICAL();
    10f4:	80 93 48 07 	sts	0x0748, r24	; 0x800748 <uxTasksDeleted>
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
    10f8:	0f 90       	pop	r0
    10fa:	0f be       	out	0x3f, r0	; 63
		vPortFree( pxTCB );
    10fc:	f8 01       	movw	r30, r16
    10fe:	87 89       	ldd	r24, Z+23	; 0x17

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
    1100:	90 8d       	ldd	r25, Z+24	; 0x18
    1102:	07 d8       	rcall	.-4082   	; 0x112 <vPortFree>
			{
				taskYIELD();
    1104:	c8 01       	movw	r24, r16
    1106:	05 d8       	rcall	.-4086   	; 0x112 <vPortFree>
    1108:	88 81       	ld	r24, Y
    110a:	82 30       	cpi	r24, 0x02	; 2
    110c:	a0 f2       	brcs	.-88     	; 0x10b6 <prvIdleTask+0x10>
    110e:	64 dc       	rcall	.-1848   	; 0x9d8 <vPortYield>
    1110:	d2 cf       	rjmp	.-92     	; 0x10b6 <prvIdleTask+0x10>

00001112 <vTaskSwitchContext>:
#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    1112:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <uxSchedulerSuspended>
    1116:	81 11       	cpse	r24, r1
    1118:	13 c0       	rjmp	.+38     	; 0x1140 <vTaskSwitchContext+0x2e>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    111a:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <uxTopReadyPriority>
    111e:	90 e0       	ldi	r25, 0x00	; 0
    1120:	fc 01       	movw	r30, r24
    1122:	ee 0f       	add	r30, r30
    1124:	ff 1f       	adc	r31, r31
    1126:	ee 0f       	add	r30, r30
    1128:	ff 1f       	adc	r31, r31
    112a:	ee 0f       	add	r30, r30
    112c:	ff 1f       	adc	r31, r31
    112e:	8e 0f       	add	r24, r30
    1130:	9f 1f       	adc	r25, r31
    1132:	fc 01       	movw	r30, r24
    1134:	ef 58       	subi	r30, 0x8F	; 143
    1136:	f8 4f       	sbci	r31, 0xF8	; 248
    1138:	80 81       	ld	r24, Z
    113a:	88 23       	and	r24, r24
    113c:	29 f0       	breq	.+10     	; 0x1148 <vTaskSwitchContext+0x36>
    113e:	1b c0       	rjmp	.+54     	; 0x1176 <vTaskSwitchContext+0x64>
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    1140:	81 e0       	ldi	r24, 0x01	; 1
    1142:	80 93 3f 07 	sts	0x073F, r24	; 0x80073f <xMissedYield>
    1146:	08 95       	ret
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    1148:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <uxTopReadyPriority>
    114c:	81 50       	subi	r24, 0x01	; 1
    114e:	80 93 43 07 	sts	0x0743, r24	; 0x800743 <uxTopReadyPriority>
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    1152:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <uxTopReadyPriority>
    1156:	90 e0       	ldi	r25, 0x00	; 0
    1158:	fc 01       	movw	r30, r24
    115a:	ee 0f       	add	r30, r30
    115c:	ff 1f       	adc	r31, r31
    115e:	ee 0f       	add	r30, r30
    1160:	ff 1f       	adc	r31, r31
    1162:	ee 0f       	add	r30, r30
    1164:	ff 1f       	adc	r31, r31
    1166:	8e 0f       	add	r24, r30
    1168:	9f 1f       	adc	r25, r31
    116a:	fc 01       	movw	r30, r24
    116c:	ef 58       	subi	r30, 0x8F	; 143
    116e:	f8 4f       	sbci	r31, 0xF8	; 248
    1170:	80 81       	ld	r24, Z
    1172:	88 23       	and	r24, r24
    1174:	49 f3       	breq	.-46     	; 0x1148 <vTaskSwitchContext+0x36>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    1176:	80 91 43 07 	lds	r24, 0x0743	; 0x800743 <uxTopReadyPriority>
    117a:	90 e0       	ldi	r25, 0x00	; 0
    117c:	9c 01       	movw	r18, r24
    117e:	22 0f       	add	r18, r18
    1180:	33 1f       	adc	r19, r19
    1182:	22 0f       	add	r18, r18
    1184:	33 1f       	adc	r19, r19
    1186:	22 0f       	add	r18, r18
    1188:	33 1f       	adc	r19, r19
    118a:	28 0f       	add	r18, r24
    118c:	39 1f       	adc	r19, r25
    118e:	d9 01       	movw	r26, r18
    1190:	af 58       	subi	r26, 0x8F	; 143
    1192:	b8 4f       	sbci	r27, 0xF8	; 248
    1194:	11 96       	adiw	r26, 0x01	; 1
    1196:	ed 91       	ld	r30, X+
    1198:	fc 91       	ld	r31, X
    119a:	12 97       	sbiw	r26, 0x02	; 2
    119c:	02 80       	ldd	r0, Z+2	; 0x02
    119e:	f3 81       	ldd	r31, Z+3	; 0x03
    11a0:	e0 2d       	mov	r30, r0
    11a2:	12 96       	adiw	r26, 0x02	; 2
    11a4:	fc 93       	st	X, r31
    11a6:	ee 93       	st	-X, r30
    11a8:	11 97       	sbiw	r26, 0x01	; 1
    11aa:	2c 58       	subi	r18, 0x8C	; 140
    11ac:	38 4f       	sbci	r19, 0xF8	; 248
    11ae:	e2 17       	cp	r30, r18
    11b0:	f3 07       	cpc	r31, r19
    11b2:	29 f4       	brne	.+10     	; 0x11be <vTaskSwitchContext+0xac>
    11b4:	22 81       	ldd	r18, Z+2	; 0x02
    11b6:	33 81       	ldd	r19, Z+3	; 0x03
    11b8:	fd 01       	movw	r30, r26
    11ba:	32 83       	std	Z+2, r19	; 0x02
    11bc:	21 83       	std	Z+1, r18	; 0x01
    11be:	fc 01       	movw	r30, r24
    11c0:	ee 0f       	add	r30, r30
    11c2:	ff 1f       	adc	r31, r31
    11c4:	ee 0f       	add	r30, r30
    11c6:	ff 1f       	adc	r31, r31
    11c8:	ee 0f       	add	r30, r30
    11ca:	ff 1f       	adc	r31, r31
    11cc:	8e 0f       	add	r24, r30
    11ce:	9f 1f       	adc	r25, r31
    11d0:	fc 01       	movw	r30, r24
    11d2:	ef 58       	subi	r30, 0x8F	; 143
    11d4:	f8 4f       	sbci	r31, 0xF8	; 248
    11d6:	01 80       	ldd	r0, Z+1	; 0x01
    11d8:	f2 81       	ldd	r31, Z+2	; 0x02
    11da:	e0 2d       	mov	r30, r0
    11dc:	86 81       	ldd	r24, Z+6	; 0x06
    11de:	97 81       	ldd	r25, Z+7	; 0x07
    11e0:	90 93 96 07 	sts	0x0796, r25	; 0x800796 <pxCurrentTCB+0x1>
    11e4:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <pxCurrentTCB>
    11e8:	08 95       	ret

000011ea <__umulhisi3>:
    11ea:	a2 9f       	mul	r26, r18
    11ec:	b0 01       	movw	r22, r0
    11ee:	b3 9f       	mul	r27, r19
    11f0:	c0 01       	movw	r24, r0
    11f2:	a3 9f       	mul	r26, r19
    11f4:	70 0d       	add	r23, r0
    11f6:	81 1d       	adc	r24, r1
    11f8:	11 24       	eor	r1, r1
    11fa:	91 1d       	adc	r25, r1
    11fc:	b2 9f       	mul	r27, r18
    11fe:	70 0d       	add	r23, r0
    1200:	81 1d       	adc	r24, r1
    1202:	11 24       	eor	r1, r1
    1204:	91 1d       	adc	r25, r1
    1206:	08 95       	ret

00001208 <memset>:
    1208:	dc 01       	movw	r26, r24
    120a:	01 c0       	rjmp	.+2      	; 0x120e <memset+0x6>
    120c:	6d 93       	st	X+, r22
    120e:	41 50       	subi	r20, 0x01	; 1
    1210:	50 40       	sbci	r21, 0x00	; 0
    1212:	e0 f7       	brcc	.-8      	; 0x120c <memset+0x4>
    1214:	08 95       	ret

00001216 <strncpy>:
    1216:	fb 01       	movw	r30, r22
    1218:	dc 01       	movw	r26, r24
    121a:	41 50       	subi	r20, 0x01	; 1
    121c:	50 40       	sbci	r21, 0x00	; 0
    121e:	48 f0       	brcs	.+18     	; 0x1232 <strncpy+0x1c>
    1220:	01 90       	ld	r0, Z+
    1222:	0d 92       	st	X+, r0
    1224:	00 20       	and	r0, r0
    1226:	c9 f7       	brne	.-14     	; 0x121a <strncpy+0x4>
    1228:	01 c0       	rjmp	.+2      	; 0x122c <strncpy+0x16>
    122a:	1d 92       	st	X+, r1
    122c:	41 50       	subi	r20, 0x01	; 1
    122e:	50 40       	sbci	r21, 0x00	; 0
    1230:	e0 f7       	brcc	.-8      	; 0x122a <strncpy+0x14>
    1232:	08 95       	ret

00001234 <_exit>:
    1234:	f8 94       	cli

00001236 <__stop_program>:
    1236:	ff cf       	rjmp	.-2      	; 0x1236 <__stop_program>
